```{r echo = FALSE}
library(knitr)

# Color text
colorize <- function(x, color) {
  
  if (knitr::is_latex_output()) {
    
    sprintf("\\textcolor{%s}{%s}", color, x)
    
  } else if (knitr::is_html_output()) {
    
    sprintf("<span style='color: %s;'>%s</span>", color, x)
    
  } else { x }
}
```

# (PART) Recursos {-}

# üìù Ejercicios recopilados {-}

Aqu√≠ haremos una recopilaci√≥n de los ejercicios planteados a lo largo del curso. Vuelve por aqu√≠ si quieres cuando acabas las lecciones para repasar aquellos ejercicios que m√°s te hayan costado.


## Primeros pasos {-}

:::: {.blackbox data-latex=""}

Scripts usados:

* [**script04.R**](https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script04.R): toma de contacto.  Ver en <https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script04.R>
::::


(haz click en las flechas para ver soluciones)

<details>
  <summary>üìù<strong>Ejercicio 1</strong>: en tu consola (parte inferior de tu pantalla), asigna los valores `2` y `5` a dos variables `a` y `b`. Tras asignarles valores, multiplica los n√∫meros en consola (**haz click** en la flecha para la soluci√≥n propuesta). </summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
# Para poner comentarios en el c√≥digo se usa #

# Definici√≥n de variables
a <- 2
b <- 5

# Multiplicaci√≥n
a * b
```

```{r consola-multi-2a, echo = FALSE, out.width = "80%", fig.align = "center", fig.cap = "Multiplicaci√≥n de a y b."}
knitr::include_graphics("./img/consola_multiplicacion.jpg")
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 2</strong>: modifica el c√≥digo inferior para definir dos variables `c` y `d`, con valores `3` y `-1`, y calcular la divisi√≥n `c/d` (**haz click** en la flecha para la soluci√≥n propuesta).
  
```{r eval = FALSE}
# Definici√≥n de variables
c <- 
d <-

# Operaci√≥n (divisi√≥n)
c ? d
```
</summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
# Definici√≥n de variables
c <- 3
d <- -1

# Divisi√≥n
a / b
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 3</strong>: repite el ejercicio 1 pero ahora guarda el resultado de la multiplicaci√≥n final en una variable `c`. Para ver el resultado guardado en `c` escribe dicha variable en consola (**haz click** en la flecha para la soluci√≥n propuesta). </summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
# Variables
a <- 2
b <- 5

# Resultado
c <- a * b

# Muestro en consola
c
```

```{r consola-multi-2b, echo = FALSE, out.width = "80%", fig.align = "center", fig.cap = "Multiplicaci√≥n de a y b guardando el resultado."}
knitr::include_graphics("./img/consola_multiplicacion_2.jpg")
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 4</strong>: asigna ahora los valores `1`, `-2`, `3` a tres variables `a`, `b` y `c`, y calcula la ra√≠z cuadrada de cada uno. </summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
# Variables
a <- 1
b <- -2
c <- 3

# Resultado
sqrt(a)
sqrt(b)
sqrt(c)
```

<!-- tocstop -->
</details>

&nbsp;


<details>
  <summary>üìù<strong>Ejercicio 5</strong>: repite el ejercicio 3 pero ahora escribe el c√≥digo en un script (fichero de `.R`, guardado en [**script01.R**](https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script01.R)). Recuerda al acabar seleccionar las l√≠neas a ejecutar y clickar `Run`, o bien guardar el script con `Source on save` activado (**haz click** en la flecha para la soluci√≥n propuesta). </summary>
  
<!-- toc -->
- Soluci√≥n:


```{r consola-multi-3a, echo = FALSE, out.width = "80%", fig.align = "center", fig.cap = "Multiplicaci√≥n de a y b guardando el resultado pero escribiendo en el script."}
knitr::include_graphics("./img/consola_multiplicacion_3.jpg")
```

<!-- tocstop -->
</details>


&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 6</strong>: calcula en consola la suma de 3 m√°s 4, y todo ello multiplicado por 10, y as√≠gnalo a una variable `x` (**haz click** en la flecha para la soluci√≥n propuesta).</summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
x <- (3 + 4) * 10
```

<!-- tocstop -->
</details>


&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 7</strong>: asigna un valor positivo a `x` y calcula  su ra√≠z cuadrada; asigna otro negativo y calcula su valor absoluto (**haz click** en la flecha para la soluci√≥n propuesta).</summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
# Ra√≠z cuadrada
x <- 73
sqrt(x)

# Valor absoluto
y <- -73
abs(y)
```

<!-- tocstop -->
</details>

&nbsp;

**`r colorize("CONSEJO:", "#20935E")`**

Las √≥rdenes `sqrt(x)` y `abs(y)` se llaman <mark>**funciones**</mark>, y la variable que tienen entre par√©ntesis se llama **argumento de la funci√≥n**: una variable que toma de entrada la funci√≥n y con la que opera internamente.


&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 8</strong>: usando la variable `x` ya definida, calcula la resta `x - 5` y gu√°rdala en una nueva variable `z` (**haz click** en la flecha para la soluci√≥n propuesta).</summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
z <- x - 5
z
```
<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 9</strong>: usando las variables `x` y `z` ya definidas, calcula el m√°ximo de ambas, y gu√°rdalo en una nueva variable `t`. (**haz click** en la flecha para la soluci√≥n propuesta).</summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
t <- max(x, z)
t
```
<!-- tocstop -->
</details>

&nbsp;

**`r colorize("WARNING:", "#ffc107")`**

No hace falta gastar una l√≠nea por cada orden que quieras ejecutar. Tampoco necesitas guardar cada paso intermedio que realices. **`r colorize("Cuidado con la memoria", "#ffc107")`**: cada asignaci√≥n que hagas es una variable guardada que consume recursos en tu ordenador.





## Tipos de datos {-}

:::: {.blackbox data-latex=""}

Scripts usados:

* [**script05.R**](https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script05.R): tipos de datos y funciones usadas con ellos.  Ver en <https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script05.R>

::::


(haz click en las flechas para ver soluciones)

<details>
  <summary>üìù<strong>Ejercicio 1</strong>: define una variable que guarde tu edad, otra con tu nombre, otra respondiendo a la pregunta ¬´¬øtengo hermanos?¬ª y otra con la fecha de tu nacimiento. </summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
edad <- 32 # tipo numeric
nombre <- "Javier" # tipo caracter
hermanos <- TRUE # tipo hermanos
fecha_nacimiento <- as.Date("1989-09-10") # tipo fecha
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 2</strong>: define otra variable con tus apellidos y junta las variables `nombre` y `apellidos` en una sola variable `nombre_completo`. </summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
library(glue)

# Apellidos
apellidos <- "√Ålvarez Li√©bana"

# Pegamos
nombre_completo <- glue("{nombre} {apellidos}")
nombre_completo

# Otra forma
nombre_completo <- paste(nombre, apellidos)
nombre_completo
```

<!-- tocstop -->
</details>

&nbsp;


<details>
  <summary>üìù<strong>Ejercicio 3</strong>: construye una frase que diga ¬´Hola, me llamo ... y tengo ... a√±os. Nac√≠ el ... de ... de ...¬ª (con el nombre completo). </summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
library(lubridate)
dia_nacimiento <- day(fecha_nacimiento)
mes_nacimiento <- month(fecha_nacimiento)
a_nacimiento <- year(fecha_nacimiento)

glue("Hola, me llamo {nombre_completo} y tengo {edad} a√±os. Nac√≠ el {dia_nacimiento} del {mes_nacimiento} de {a_nacimiento}")
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 4</strong>: calcula los d√≠as que han pasado desde la fecha de tu nacimiento </summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
days(today() - fecha_nacimiento)
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 5</strong>: obt√©n una variable l√≥gica que nos diga si se cumplen (todas) las condiciones i) menor de 30 a√±os (`edad < 30`); ii) con hermanos (`hermanos == TRUE`); iii) nacido en 1990 o posterior (`fecha_nacimiento >= as.Date("1990-01-01")`). </summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
# Se tienen que cumplir todas
edad < 30 & fecha_nacimiento >= as.Date("1990-01-01") & hermanos
```

```{r}
# otra forma
edad < 30 & fecha_nacimiento >= as.Date("1990-01-01") & hermanos == TRUE
```

<!-- tocstop -->
</details>


&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 6</strong>: modifica el c√≥digo del ejercicio anterior para obtener una variable l√≥gica que nos diga si se cumplen (al menos) alguna de las condiciones i) menor de 30 a√±os; ii) con hermanos; iii) nacido en 1990 o posterior. Al contrario que antes, no necesitamos que se cumplan todas, nos basta con que se cumple al menos una. </summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
# Se tienen que cumplir todas
edad < 30 | fecha_nacimiento >= as.Date("1990-01-01") | hermanos
```

<!-- tocstop -->
</details>


&nbsp;


<details>
  <summary>üìù<strong>Ejercicio 7</strong>: calcula la fecha 11 d√≠as m√°s tarde a tu fecha de nacimiento. Obt√©n la semana del a√±o de dicha fecha y el d√≠a de la semana con las funciones `week`, `wday` y `weekdays`. </summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
# Podemos sumar porque es fecha
fecha_post <- fecha_nacimiento + 11
fecha_post

# Semana del a√±o
week(fecha_post)

# D√≠a de la semana (versi√≥n americana, empiezan el domingo)
wday(fecha_post)

# D√≠a de la semana (versi√≥n espa√±ola)
wday(fecha_post, week_start = 1)

# D√≠a de la semana en texto
weekdays(fecha_post)
```

<!-- tocstop -->
</details>


&nbsp;



<details>
  <summary>üìù<strong>Ejercicio 8</strong>: define dos n√∫meros cualesquiera en variable `a` y `b`. Calcula su suma y determina cual es mayor. </summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
a <- -5
b <- 7

# Suma
c <- a + b
c

# Comparaciones
a == b # ¬øa = b?
a < b # ¬øa < b?
```

<!-- tocstop -->
</details>


&nbsp;





## Vectores {-}

:::: {.blackbox data-latex=""}

Scripts usados:

* [**script06.R**](https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script06.R): vectores.  Ver en <https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script06.R>

::::


(haz click en las flechas para ver soluciones)

<details>
  <summary>üìù<strong>Ejercicio 1</strong>: modifica el c√≥digo anterior para crear un vector de nombre `vector_num` que contenga los n√∫meros 1, 5 y -7.
```{r eval = FALSE}
# Vector de n√∫meros
vector_num <- c(1)
vector_num
```
</summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
# Vector de n√∫meros
vector_num <- c(1, 5, -7)
vector_num
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 2</strong>: define un vector que contenga los n√∫meros 1, 10, -1 y 2, y gu√°rdalo en una variable llamada `vector_num`. </summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
# Vector de n√∫meros
vector_num <- c(1, 10, -1, 2)
vector_num
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 3</strong>: obt√©n la longitud del vector anterior `vector_num`. </summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
# Longitud del vector
length(vector_num)
```

<!-- tocstop -->
</details>

&nbsp;


<details>
  <summary>üìù<strong>Ejercicio 4</strong>: crea un vector con las palabras "Hola", "me", "llamo" (y tu nombre y apellidos), y pega luego sus elementos de forma que la frase est√© correctamente escrita en castellano. Tras hacerlo, a√±ade "y tengo 30 a√±os". </summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
# Definiendo el vector
vector_char <- c("Hola", "me", "llamo", "Javier",
                 "√Ålvarez", "Li√©bana")

# Pegamos
frase <- paste(vector_char, collapse = " ")
frase

# A√±adimos frase
glue("{frase} y tengo 30 a√±os.")

# Otra forma
paste0(frase, " y tengo 30 a√±os.")

# Otra forma
paste(frase, "y tengo 30 a√±os.")
```

<!-- tocstop -->
</details>

&nbsp;


<details>
<summary>üìù<strong>Ejercicio 5</strong>: el c√≥digo inferior crea una secuencia de n√∫meros, que empieza en `-1`, que acaba en `32`, y que va saltando de 2 en 2. Mod√≠ficalo para que haga el salto de 3 en 3 y gu√°rdalo en una variable llamada `secuencia`.

```{r eval = FALSE}
seq(-1, 32, by = 2)
```
  </summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
secuencia <- seq(-1, 32, by = 3)
secuencia
length(secuencia) # longitud de la secuencia
```

<!-- tocstop -->
</details>

&nbsp;


<details>
  <summary>üìù<strong>Ejercicio 6</strong>: crea una secuencia de n√∫meros, que empiece en `-1`, que acabe en `32`, y que tenga longitud 12. </summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
secuencia <- seq(-1, 32, l = 12)
secuencia
length(secuencia) # longitud de la secuencia
```

<!-- tocstop -->
</details>

&nbsp;


<details>
  <summary>üìù<strong>Ejercicio 7</strong>: crea una secuencia que empiece en 1 y recorra todos los naturales hasta el 10. Despu√©s crea otra secuencia de longitud 7 que todos los n√∫meros sean `3`.  </summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
1:10
rep(3, 7) # secuencia repetida
```

<!-- tocstop -->
</details>

&nbsp;


<details>
  <summary>üìù<strong>Ejercicio 8</strong>: crea una secuencia que repita 5 veces el patr√≥n `1, 2, 3`. Despu√©s crea otra que repita dicho patr√≥n pero de forma intercalada, con 5 veces `1`, despu√©s 5 veces `2` y despu√©s 5 veces `3`.</summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
rep(c(1, 2, 3), 5) # repetimos patr√≥n (1, 2, 3) 5 veces
rep(c(1, 2, 3), each = 5) # repetimos patr√≥n alternado
```

<!-- tocstop -->
</details>

&nbsp;


<details>
  <summary>üìù<strong>Ejercicio 9</strong>: crea un vector con las edades de cuatro conocidos o familiares. Tras ello, determina cu√°les de ellos tienen menos de 20 a√±os, 30 a√±os o m√°s, menos de 40 a√±os y m√°s de 65 a√±os.</summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
edades <- c(27, 32, 60, 61) # en mi caso, por ejemplo
edades < 20 # menos de 20 a√±os
edades >= 30 # 30 a√±os o m√°s
edades < 40 # menos de 40 a√±os
edades > 65 # m√°s de 65 a√±os
```

<!-- tocstop -->
</details>







## Operaciones con vectores {-}

:::: {.blackbox data-latex=""}

Scripts usados:

* [**script07.R**](https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script07.R): operaciones con vectores.  Ver en <https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script07.R>

::::

(haz click en las flechas para ver soluciones)

<details>
  <summary>üìù<strong>Ejercicio 1</strong>: define de nuevo el vector `vector_num` definido como un vector que contenga los n√∫meros 1, 10, -1 y 2) y calcula su suma del vector. </summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
# Vector de n√∫meros
vector_num <- c(1, 10, -1, 2)

# Suma
sum(vector_num)
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 2</strong>: define otro vector `vector_num2` que contenga los n√∫meros `5, -7, 8, -3`, y haz la suma de `vector_num` y `vector_num2`. </summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
# Vector de n√∫meros
vector_num2 <- c(5, -7, 8, -3)

# Suma
vector_num + vector_num2
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 3</strong>: calcula el n√∫mero de elementos mayores que 0 del resultado de la suma de `vector_num` y `vector_num2`. </summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
# Vector de n√∫meros
vector_suma <- vector_num + vector_num2

# Suma
sum(vector_suma > 0)
```

<!-- tocstop -->
</details>


&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 4</strong>: calcula la versi√≥n ordenada del vector `vector_num`. </summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
# Ordenamos el vector (con sort)
sort(vector_num)

# Ordenamos el vector  (con order)
vector_num[order(vector_num)]
```

<!-- tocstop -->
</details>

&nbsp;



<details>
  <summary>üìù<strong>Ejercicio 5</strong>: encuentra del vector `vector_num` original el lugar (el √≠ndice) que ocupa su m√≠nimo y su m√°ximo. </summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
vector_num <- c(1, 10, -1, 2)

# Encontrando el lugar que ocupa el m√°ximo y m√≠nimo
which.max(vector_num)
which.min(vector_num)
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 6</strong>: encuentra del vector `vector_num` los elementos mayores que 1 y menores que 7. Encuentra una forma de averiguar si todos los elementos son o no positivos. </summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
# Vector l√≥gico: mayores que 1 y menores que 7
vector_num > 1 & vector_num < 7

# ¬øSon todos positivos?
all(vector_num > 0)
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 7</strong>: define el vector `c(-1, 0, 4, 5, -2)`, calcula la ra√≠z cuadrada del vector y determina que lugares son ausente de tipo `NaN`. </summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
# Vector
x <- c(-1, 0, 4, 5, -2)

# ¬øCu√°les son ausentes tras aplicar la ra√≠z cuadrada?
is.nan(sqrt(x))
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 8</strong>: define el vector de los primeros n√∫meros impares (hasta el 21) y extrae los elementos que ocupan los lugares 1, 4, 5, 8. Elimina del vector el segundo elemento</summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
# Vector de impares (de 1 a 21 saltando de dos en dos)
x <- seq(1, 21, by = 2)

# Seleccionamos elementos
x[c(1, 4, 5, 8)]

# Eliminamos elementos
y <- x[-2]
y
```

<!-- tocstop -->
</details>




## Estructuras de datos: matrices y tablas (data.frame) {-}

:::: {.blackbox data-latex=""}

Scripts usados:

* [**script08.R**](https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script08.R): matrices y data.frames.  Ver en <https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script08.R>
::::

(haz click en las flechas para ver soluciones)

<details>
  <summary><strong>Ejercicio 1</strong>: modifica el c√≥digo para definir una matriz `x` de ceros de 3 filas y 7 columnas.
```{r eval = FALSE}
# Matriz
x <- matrix(0, nrow = 2, ncol = 3)
x
```
</summary>

- Soluci√≥n:

```{r}
# Matriz
x <- matrix(0, nrow = 3, ncol = 7)
x
```

</details>

&nbsp; 

<details>
  <summary><strong>Ejercicio 2</strong>: a la matriz anterior, suma un 1 a cada n√∫mero de la matriz y divide el resultado entre 5.</summary>

- Soluci√≥n:

```{r}
(x + 1) / 5
```

</details>

&nbsp; 


<details>
  <summary><strong>Ejercicio 3</strong>: tras definir la matriz `x` calcula su transpuesta y obt√©n sus dimensiones</summary>

- Soluci√≥n:

```{r}
# Transpuesta
t(x)

# Dimensiones transpuesta: pasa de ser 3x7 a 7x3
dim(t(x))
ncol(t(x)) # n√∫mero de columnas de la transpuesta
nrow(t(x)) # n√∫mero de filas de la transpuesta
```

</details>

&nbsp;

<details>
  <summary><strong>Ejercicio 4</strong>: el siguiente c√≥digo define una matriz de dimensiones `4 x 3` y calcula la suma por columnas. Modifica el c√≥digo para que realice la suma por filas.
  
```{r}
# Matriz
matriz <- matrix(1:12, nrow = 4)

# Suma por columnas
apply(matriz, MARGIN = 2, FUN = "sum")
```
</summary>


- Soluci√≥n:

```{r}
# Matriz
matriz <- matrix(1:12, nrow = 4)

# Suma por filas
apply(matriz, MARGIN = 1, FUN = "sum")
```
</details>

&nbsp; 

<details>
  <summary><strong>Ejercicio 5</strong>: con la matriz anterior definida como `matrix(1:12, nrow = 4)`, calcula la media de todos los elementos, la media de cada fila y la media de cada columna.</summary>

- Soluci√≥n:

```{r}
# Matriz
matriz <- matrix(1:12, nrow = 4)

#  media de todos
mean(matriz)

# Media por filas (MARGIN = 1 ya que es una operaci√≥n por filas)
apply(matriz, MARGIN = 1, FUN = "mean")

# Media por filas (MARGIN = 2 ya que es una operaci√≥n por filas)
apply(matriz, MARGIN = 2, FUN = "mean")
```
</details>

&nbsp; 

<details>
  <summary><strong>Ejercicio 6</strong>: el `data.frame` llamado `airquality`, del paquete `{datasets}`, contiene variables de la calidad del aire de la ciudad de Nueva York desde mayo hasta septiembre de 1973. Obt√©n el nombre de las variables.
</summary>
  
- Soluci√≥n:

```{r}
library(datasets)
names(airquality)
```

</details>

 &nbsp; 

<details>
  <summary><strong>Ejercicio 7</strong>: obt√©n las dimensiones del conjunto de datos. ¬øCu√°ntas variables hay? ¬øCu√°ntos d√≠as se han medido?
  
</summary>
  
- Soluci√≥n:

```{r}
# Dimensiones
dim(airquality)
nrow(airquality)
ncol(airquality)
```

</details>

&nbsp; 

<details>
  <summary><strong>Ejercicio 8</strong>: modifica el c√≥digo inferior para que nos filtre solo los datos del mes de julio.
  
```{r eval = FALSE}
# Filtramos filas
filtro_fila <- subset(., subset = Month < 6)
filtro_fila
```
</summary>
  
- Soluci√≥n:

```{r}
# Filtramos filas
filtro_fila <- subset(airquality, subset = Month == 7)
filtro_fila
```

</details>

&nbsp; 

<details>
  <summary><strong>Ejercicio 9</strong>: del conjunto `airquality` selecciona aquellos datos que no sean ni de julio ni de agosto.</summary>
  
- Soluci√≥n:

```{r}
# Filtramos filas
filtro_fila <-
  subset(airquality, subset = !(Month %in% c(7, 8)))
filtro_fila
```

</details>

&nbsp; 

<details>
  <summary><strong>Ejercicio 10</strong>: modifica el siguiente c√≥digo para quedarte solo con las variable `Ozone` y `Temp`.
  
```{r eval = FALSE}
filtro_col <- subset(.,  select = c("Ozone"))
filtro_col
```

</summary>
  
- Soluci√≥n:

```{r}
# Filtramos columnas
filtro_col <- subset(airquality,  select = c("Ozone", "Temp"))
filtro_col
```

</details>


&nbsp; 

<details>
  <summary><strong>Ejercicio 11</strong>: del conjunto `airquality` selecciona los datos de temperatura y viento de agosto.</summary>
  
- Soluci√≥n:

```{r}
# Todo de una vez
filtro <- subset(airquality, subset = Month == 8,
                 select = c("Temp", "Wind"))
filtro
```

</details>


&nbsp; 

<details>
  <summary><strong>Ejercicio 12</strong>: calcula el n√∫mero de filas borradas del ejercicio anterior. Tras hacer todo ello, traduce a castellano el nombre de las columnas del `data.frame` filtrado.</summary>
  
- Soluci√≥n:

```{r}
# Filas borradas
nrow(airquality) - nrow(filtro)

# Cambiamos nombres a castellano del conjunto filtrado
names(filtro) <- c("temperatura", "viento")
```

</details>

&nbsp; 

<details>
  <summary><strong>Ejercicio 13</strong>: a√±ade a los datos originales una columna con la fecha completa (recuerda que es del a√±o 1973 todas las observaciones.</summary>
  
- Soluci√≥n:

```{r}
# Construimos las fechas (pegamos a√±o-mes-d√≠a con "-")
fechas <- 
  as.Date(paste("1973", airquality$Month, airquality$Day,
                sep = "-"))

# A√±adimos
data.frame(airquality, fechas)
```

</details>

&nbsp; 






## Repaso: empezando a trastear datos {-}

:::: {.blackbox data-latex=""}

Scripts usados:

* [**script09.R**](https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script09.R): repaso.  Ver en <https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script09.R>
::::

<mark>**1. ¬øC√≥mo cargar√≠as los datos sabiendo su nombre y el paquete en el que est√°?**</mark>

&nbsp;
  

Nuestros datos se llaman `swiss` y son del paquete `{datasets}`, as√≠ que lo primero que debemos hacer es instalar el paquete (en caso de no haberlo hecho a√∫n, con `install.packages("datasets")`), despu√©s **llamar a ese paquete** (tenemos el libro comprado y lo sacamos de la estanter√≠a) con `library(datasets)` y escribir el nombre del conjunto de datos para mostrarlo.

```{r}
library(datasets)
swiss
```

Podr√≠amos no pedirle el libro entero sino **solo esa p√°gina**, de ese conjunto de datos, usando `datasets::swiss` (sin hacer uso del `library()` previo).


```{r eval = FALSE}
datasets::swiss
```

&nbsp;

<mark>**2. Tenemos los datos guardados en `swiss`, ¬øqu√© tipo de objeto es?**</mark>

&nbsp;

Al mostrarlos ya lo habr√°s intuido pero nuestro conjunto `swiss` es de tipo `data.frame`. Para comprobarlo podemos usar la funci√≥n `class()`.

```{r}
class(swiss)
```

Si somos un poco observadores/as vemos que todas las variables parecen num√©ricas as√≠ que...podr√≠amos tener una matriz de n√∫meros. <mark>**¬øC√≥mo convertimos los datos a una matriz?**</mark>

```{r}
as.matrix(swiss)
class(as.matrix(swiss))
```

&nbsp;

<mark>**3. ¬øC√≥mo podr√≠amos tener una descripci√≥n detallada de los datos?**</mark>

&nbsp;

La forma m√°s inmediata es hacerlo es con la funci√≥n `? swiss`, que nos permite ver la documentaci√≥n en el panel de ayuda.

```{r eval = FALSE}
? swiss
```

Tambi√©n podemos ver el nombre de las columnas con `names()` y el nombre de las filas con `row.names()`

```{r}
names(swiss)
row.names(swiss)
```

Los datos representan algunos **indicadores de fertilidad y socioecon√≥micos** (estandarizados, entre 0 y 100) de las 47 provincias francoparlantes de Suiza, con datos del a√±o 1888. Como podemos **leer en la ayuda**, en la web <https://opr.princeton.edu/archive/pefp/switz.aspx> tenemos los datos de 182 distritos para dicho a√±o.

&nbsp;

<mark>**4. ¬øC√≥mo podr√≠amos ¬´ver¬ª los datos? ¬øCu√°ntas provincias hay incluidas? ¬øCu√°ntas variables han sido medidas en cada una de ellas?**</mark>

&nbsp;

Podemos hacerlo de varias maneras, y una de ellas es pedirle una **cabecera** de la tabla (las primeras filas) con `head()`.

```{r}
head(swiss)
```

Tambi√©n podemos ver una versi√≥n ¬´excelizada¬ª de los datos con `View()

```{r eval = FALSE}
View(swiss)
```

Para **ver las dimensiones de los datos** podemos recurrir a `dim()` (nos dar√° un vector de longitud 2 con el n√∫mero de filas y columnas) o a `nrow()` y `ncol()`

```{r}
dim(swiss)
nrow(swiss)
ncol(swiss)
```
  
&nbsp;

<mark>**5. ¬øC√≥mo podr√≠amos definir una nueva variable de tipo texto con los nombres de filas que obtenemos de `row.names()`?**</mark>

&nbsp;

La funci√≥n `row.names()` nos devuelve los nombres de las filas, que vamos a guardar en una variable (por ejemplo, en `nombres`).

```{r}
nombres <- row.names(swiss)
nombres
```
## Estructuras condicionales {-}

:::: {.blackbox data-latex=""}

Scripts usados:

* [**script10.R**](https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script10.R): if-else.  Ver en <https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script10.R>
::::


(haz click en las flechas para ver soluciones)

<details>
  <summary>üìù<strong>Ejercicio 1</strong>: modifica el c√≥digo inferior para imprimir un mensaje por pantalla si todos los datos del conjunto `airquality` son de meses que no sean enero.
  
```{r eval = FALSE}
library(datasets) # paquete con los adtos
mes <- airquality$Month

if (mes == 2) {
  
  print("Ning√∫n dato es del mes de enero")
  
}
  
```
</summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
library(datasets) # paquete con los datos
mes <- airquality$Month

if (all(mes != 1)) { # todos con mes distinto de 1
  
  print("Ning√∫n dato es del mes de enero")
  
}

```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 2</strong>: modifica el c√≥digo inferior para imprimir un mensaje por pantalla si alguno de los registros tiene una temperatura mayor a 90 (Farenheit).
  
```{r eval = FALSE}
temperatura <- airquality$Temp

if (temperatura  == 100) {
  
  print("Alguno de los registros tiene temperatura superior a 90 Farenheit")
  
}
  
```
</summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
temperatura <- airquality$Temp

if (any(temperatura > 90)) {
  
  print("Alguno de los registros tiene temperatura superior a 90 Farenheit")
  
}

```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 3</strong>: modifica el c√≥digo inferior para imprimir un mensaje por pantalla si alguno de los d√≠as supera la temperatura de 100.
  
```{r eval = FALSE}
temperatura <- airquality$Temp

if (all(temperatura < 50)) {
  
  print("Alguno de los registros tiene temperatura superior a 100 Farenheit")
  
}
  
```

</summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
temperatura <- airquality$Temp

if (any(temperatura > 100)) { # nos basta con uno
  
  print("Alguno de los registros tiene temperatura superior a 100 Farenheit")
  
}

```

No imprime nada porque ninguno cumple la condici√≥n.


<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 4</strong>: del paquete `{lubridate}`, la funci√≥n `hour()` nos devuelve la hora de una fecha dada, y la funci√≥n `now()` nos devuelve fecha y hora del momento actual. Con ambas funciones, y usando `if`, imprime por pantalla  `"buenas noches"` solo a partir de las 21 horas. </summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
# Cargamos librer√≠a
library(lubridate)

# Fecha-hora actual
fecha_actual <- now()

# Estructura if
if (hour(fecha_actual) > 21) {
  
  cat("Buenas noches") # print/cat dos formas de imprimir por pantalla
}
```

<!-- tocstop -->
</details>

&nbsp;


<details>
  <summary>üìù<strong>Ejercicio 5</strong>: con las funciones del ejercicio anterior, y usando una estructura `if-else`, imprime por pantalla `"buenos d√≠as"` (de 6 a 14 horas), `"buenas tardes"` (de 14 a 21 horas) o `"buenas noches"` (de las 21 a las 6 horas). </summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
# Fecha actual
fecha_actual <- now()

# Estructura if-else
if (hour(fecha_actual) > 6 & hour(fecha_actual) < 14) {
  
  cat("Buenos d√≠as")
  
} else if (hour(fecha_actual) > 14 & hour(fecha_actual) < 21) {
  
  cat("Buenas tardes")
  
} else {
  
  cat("Buenas noches")
}
```

<!-- tocstop -->
</details>

&nbsp;


<details>
  <summary>üìù<strong>Ejercicio 6</strong>: realiza el ejercicio anterior pero sin estructura de llaves, de forma concisa con `ifelse()`. Mira la ayuda si la necesitases poniendo `? ifelse`. </summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
# Fecha actual
fecha_actual <- now()

# Estructura if-else
cat(ifelse(hour(fecha_actual) > 6 & hour(fecha_actual) < 14,
           "Buenos d√≠as",
           ifelse(hour(fecha_actual) > 14 &
                    hour(fecha_actual) < 21,
                  "Buenas tardes", "Buenas noches")))
  
```

<!-- tocstop -->
</details>

&nbsp;





## Bucles {-}

:::: {.blackbox data-latex=""}

Scripts usados:

* [**script11.R**](https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script11.R): bucles.  Ver en <https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script11.R>
::::

(haz click en las flechas para ver soluciones)

<details>
  <summary>üìù<strong>Ejercicio 1</strong>: modifica el c√≥digo interior para dise√±ar un bucle `for` de 5 iteraciones que recorra los 5 primeros impares y les sume uno.
  
```{r}
for (i in 1:5) {
  
  print(i)
}
```

</summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
# Una forma
for (i in seq(1, 9, by = 2)) {
  
  print(i + 1)
}

# Otra
for (i in c(1, 3, 5, 7, 9)) {
  
  print(i + 1)
}
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 2</strong>: modifica el c√≥digo interior para dise√±ar un bucle `while` que parta con una variable `conteo <- 1` y pare cuando llegue a 6.
  
```{r}
conteo <- 1
while (conteo == 2) {
  
  print(conteo)
}
```

</summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
conteo <- 1
while (conteo < 6) {
  
  print(conteo)
  conteo <- conteo <- conteo + 1
}
```

<!-- tocstop -->
</details>

&nbsp;


<details>
  <summary>üìù<strong>Ejercicio 3</strong>: construye un bucle que recorra las primeras 8 filas del conjunto de datos `MASS::mammals` y que imprima el peso del animal (en kg) multiplicado por 1000 (gramos).

</summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
for (i in 1:8) {
  
  print(MASS::mammals$body[i] * 1000)
}
```

<!-- tocstop -->
</details>

&nbsp;


<details>
  <summary>üìù<strong>Ejercicio 4</strong>: dise√±a un bucle `for` de 200 iteraciones que, empezando en un valor inicial de 100 (euros), te sume 3‚Ç¨ si el n√∫mero actual es par y te reste 5‚Ç¨ si es impar.

Un n√∫mero par o impar: un n√∫mero par ser√° todo aquel n√∫mero que al dividir entre 2, la divisi√≥n es exacta, es decir, que su resto es nulo. Por ejemplo, al dividir 5 entre 2, el resto es 1, pero al dividir 12 entre 2 el resto es 0. Para calcula ese resto usaremos la funci√≥n `%%`.

```{r}
5 %% 2
12 %% 2
23 %% 2
46 %% 2
```
</summary>
  
<!-- toc -->
- Soluci√≥n:


```{r}
# dinero inicial
dinero <- 100

# Bucle for
for (i in 1:200) {
  
  dinero <- ifelse(dinero %% 2 == 0, dinero + 3, dinero  - 5)
  
}
dinero
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 5</strong>: dise√±a el anterior bucle pero guardando el dinero de cada iteraci√≥n.</summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
# vector de importes
dinero <- rep(0, 201)
dinero[1] <- 100 # dinero inicial

# Bucle for
for (i in 2:201) {
  
  # si dinero[i - 1] es par o  impar
  dinero[i] <- ifelse(dinero[i - 1] %% 2 == 0, dinero[i - 1] + 3,
                      dinero[i - 1]  - 5)
  
}
dinero
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 6</strong>: dise√±a el bucle del ejercicio 4 parando cuando no nos quede dinero.</summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
dinero <- 100 # dinero inicial

# Bucle while
while (dinero > 0) {
  
  dinero <- ifelse(dinero %% 2 == 0, dinero + 3, dinero - 5)
  
}
dinero
```

<!-- tocstop -->
</details>






## Funciones {-}

:::: {.blackbox data-latex=""}

Scripts usados:

* [**script13.R**](https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script13.R): funciones.  Ver en <https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script13.R>
::::

(haz click en las flechas para ver soluciones)


<details>
  <summary><strong>Ejercicio 1</strong>: modifica el c√≥digo inferior para definir una funci√≥n llamada `funcion_suma`, de forma que dados dos elementos, devuelve su suma.
  
```{r eval = FALSE}
# Definimos funci√≥n
nombre <- function(x, y) {
  
  # Sumamos
  suma <- # c√≥digo a ejecutar
  
  # ¬øQu√© devolvemos?
  return()
}

# Aplicamos la funci√≥n
suma(3, 7)
```
</summary>
  
- Soluci√≥n:

```{r}
# Definimos funci√≥n
funcion_suma <- function(x, y) {
  
  # Sumamos
  suma <- x + y
  
  # Devolvemos la salida
  return(suma)
}

# Aplicamos la funci√≥n
funcion_suma(3, 7)
```

</details>

&nsbp;

<details>
  <summary><strong>Ejercicio 2</strong>: modifica el c√≥digo inferior para definir una funci√≥n llamada `funcion_producto`, de forma que dados dos elementos, devuelve su producto.
  
```{r eval = FALSE}
# Definimos funci√≥n
nombre <- function(x, y) {
  
  # Multiplicamos
  producto <- # c√≥digo de la multiplicaci√≥n
  
  # ¬øQu√© devolvemos?
  return()
}

# Aplicamos la funci√≥n
producto(3, -7)
```
</summary>
  
- Soluci√≥n:

```{r}
# Definimos funci√≥n
funcion_producto <- function(x, y) {
  
  # Multiplicamos
  producto <- x * y
  
  # Devolvemos la salida
  return(producto)
}

# Aplicamos la funci√≥n
funcion_producto(3, -7)
```

</details>

&nbsp;

<details>
  <summary><strong>Ejercicio 3</strong>: modifica el c√≥digo inferior para definir una funci√≥n llamada `funcion_producto`, de forma que dados dos elementos, devuelve su producto, pero que por defecto calcule el cuadrado (es decir, por defecto un solo argumento, y el resultado sea el n√∫mero por s√≠ mismo)
  
```{r eval = FALSE}
# Definimos funci√≥n
nombre <- function(x, y) {
  
  # Multiplicamos
  producto <- # c√≥digo de la multiplicaci√≥n
  
  # ¬øQu√© devolvemos?
  return()
}

# Aplicamos la funci√≥n solo con un argumento
producto(3)

# Aplicamos la funci√≥n con dos argumentos
producto(3, -7)
```
</summary>
  
- Soluci√≥n:

```{r}
# Definimos funci√≥n
funcion_producto <- function(x, y = x) {
  
  # Multiplicamos
  producto <- x * y
  
  # Devolvemos la salida
  return(producto)
}

# Aplicamos la funci√≥n
funcion_producto(3) # por defecto x = 3, y = 3
funcion_producto(3, -7)
```

</details>

&nbsp;

<details>
  <summary><strong>Ejercicio 4</strong>: define una funci√≥n llamada `igualdad_nombres` que, dados dos nombres `persona_1` e `persona_2`, nos diga si son iguales o no. Hazlo considerando importantes las may√∫sculas, y sin que importen las may√∫sculas. Recuerda que con `toupper()` podemos pasar todo un texto a may√∫scula. </summary>
  
- Soluci√≥n:

```{r}
# Distinguiendo may√∫sculas
igualdad_nombres <- function(persona_1, persona_2) {
  
  return(persona_1 == persona_2)
}
igualdad_nombres("Javi", "javi")
igualdad_nombres("Javi", "Luc√≠a")

# Sin importar may√∫sculas
igualdad_nombres <- function(persona_1, persona_2) {
  
  return(toupper(persona_1) == toupper(persona_2))
}
igualdad_nombres("Javi", "javi")
igualdad_nombres("Javi", "Luc√≠a")
```

</details>

&nbsp; 

<details>
  <summary><strong>Ejercicio 5</strong>: define una funci√≥n llamada `pares` que, dados dos n√∫meros `x` e `y`, nos diga si la suma de ambos es par o no.
  
Recuerda que con `%%` podemos obtener el resto de un n√∫mero al dividir entre 2.

```{r}
2 %% 2 # par, resto 0
3 %% 2 # impar, resto 1
```
</summary>
  
- Soluci√≥n:

```{r}
# Definimos funci√≥n
pares <- function(x, y) {
  
  # Sumamos
  suma <- x + y
  
  # Comprobamos si es par
  par <- suma %% 2 == 0
  
  # Devolvemos la salida
  return(par)
}

# Aplicamos la funci√≥n
pares(1, 3) # suma 4 (par)
pares(2, 7) # suma 9 (impar)
```

</details>

&nbsp; 

&nbsp; 

<details>
  <summary><strong>Ejercicio 6</strong>: define una funci√≥n llamada `pasar_a_celsius` que, dada una temperatura $x$ en Fahrenheit, la convierta a grados Celsius ($¬∫C = (¬∫F - 32) * \frac{5}{9}$). Aplica la funci√≥n a la columna `Temp` del conjunto `airquality`, e incorp√≥rala al fichero en una nueva columna `Temp_Celsius`.
</summary>
  
- Soluci√≥n:

```{r}
# Definimos funci√≥n
pasar_a_celsius <- function(x) {
  
  # Temperatura en Celsius
  x_celsius <- (x - 32) * (5 / 9)
  
  # Devolvemos la salida
  return(x_celsius)
}

# Aplicamos la funci√≥n
pasar_a_celsius(0)
pasar_a_celsius(80)

# Aplicamos
data.frame(airquality,
           "Temp_Celsius" = pasar_a_celsius(airquality$Temp))
```

</details>

&nbsp; 







## Listas {-}

:::: {.blackbox data-latex=""}

Scripts usados:

* [**script14.R**](https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script14.R): listas.  Ver en <https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script14.R>
::::


<details>
  <summary><strong>Ejercicio 1</strong>: define una lista de 4 elementos de tipos distintos y accede al segundo de ellos (yo incluir√© uno que sea un `data.frame` para que veas que en una lista cabe de todo).</summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
# Ejemplo: lista con texto, num√©rico, l√≥gico y un data.frame
lista_ejemplo <- list("nombre" = "Javier", "cp" = 28019,
                      "soltero" = TRUE,
                      "notas" = data.frame("mates" = c(7.5, 8, 9),
                                           "lengua" = c(10, 5, 6)))
lista_ejemplo

# Longitud
length(lista_ejemplo)

# Accedemos al elemento dos
lista_ejemplo[[2]]
```

</details>

&nbsp; 

<details>
  <summary><strong>Ejercicio 2</strong>: accede a los elementos que ocupan los lugares 1 y 4 de la lista definida anteriormente.</summary>
  
  
<!-- toc -->
- Soluci√≥n:

```{r}
# Accedemos al 1 y al 4
lista_ejemplo[c(1, 4)]
```

Otra opci√≥n es acceder con los nombres

```{r}
# Accedemos al 1 y al 4
lista_ejemplo$nombre
lista_ejemplo$notas

lista_ejemplo[c("nombre", "notas")]
```

</details>

&nbsp; 


<details>
  <summary><strong>Ejercicio 3</strong>: define una lista de 4 elementos que contenga, en una sola variable, tu nombre, apellido, edad y si est√°s soltero/a.</summary>
  
  
<!-- toc -->
- Soluci√≥n:

```{r}
library(lubridate)
# Creamos lista: con lubridate calculamos la diferencia de a√±os desde la fecha de nuestro nacimiento hasta hoy (sea cuando sea hoy)
lista_personal <- list("nombre" = "Javier",
                       "apellidos" = "√Ålvarez Li√©bana",
                       "edad" = 32,
                       "soltero" = TRUE)
lista_personal
```

</details>






## Tibble {-}

:::: {.blackbox data-latex=""}

Scripts usados:

* [**script15.R**](https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script15.R): datos tibble.  Ver en <https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script15.R>
::::

(haz click en las flechas para ver soluciones)

<details>
  <summary>üìù<strong>Ejercicio 1</strong>: ¬øes el conjunto de datos `airquality` (del paquete `{datasets}`) de tipo `tibble`? </summary>
  
<!-- toc -->
- Soluci√≥n:

Recuerda que podemos cargar elementos de un paquete (en este caso `{datasets}`) cargando `library(datasets)` y luego el elemento, o bien `datasets::airquality` (prefijo::nombre).

La respuesta: NO. Tienes muchas formas de comprobarlo si imprimes el conjunto por defecto.

```{r}
library(datasets)
airquality
class(airquality)
```

- Imprime por defecto todas las filas (tiene 153 filas, deber√≠a imprimir solo 10 si fuese un tibble, para no saturar consola).
- No especifica al imprimir que es de tipo `tibble`.
- No especifica al imprimir el tipo de dato de las columnas.
- Imprime el nombre de las filas (el nombre de los modelos) como si fuera una variable (¬°que no existe!).

<!-- tocstop -->
</details>

&nbsp;


<details>
  <summary>üìù<strong>Ejercicio 2</strong>: convierte el conjunto `airquality` de `data.frame` a `tibble`. </summary>
  
<!-- toc -->
- Soluci√≥n:

As√≠ deber√≠a de salir si fuera `tibble`.

```{r}
library(dplyr)
airquality_tb <- as_tibble(airquality)
airquality_tb
class(airquality_tb)
```
<!-- tocstop -->
</details>


&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 3</strong>: define un `tibble` con tres variables num√©ricas `a, b, c`, tal que la tercera sea el producto de las dos primeras `c = a * b`<mark>. Int√©ntalo hacer con un `data.frame`</summary>
  
<!-- toc -->
- Soluci√≥n:

Un ejemplo:

```{r}
tibble("a" = 1:7, "b" = 11:17, "c" = a * b)
```

Si lo intentamos con un `data.frame`, intentar√° buscar una variable real que tengamos guardada que se llame `a` y `b`, sin encontrarlas.

```{r error = TRUE}
data.frame("a" = 1:7, "b" = 11:17, "c" = a * b)
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 4</strong>: define un `tibble` con tres variables de nombres `variable`, `2`, `tercera :)`, e intenta acceder a ellas.</summary>
  
<!-- toc -->
- Soluci√≥n:

Las variables solo con caracteres del alfabeto se podr√°n acceder sin necesidad de comillas.

```{r}
# Definimos el tibble
datos_tb <- tibble("variable" = 1:7, "tercera falsa :)" = 0,
                   "2" = 11:17)

# Accedemos a sus columnas
datos_tb$variable
datos_tb$`tercera falsa :)`
datos_tb$`2`
```

Tambi√©n se puede acceder por el orden que ocupan:

```{r}
datos_tb[1]
datos_tb[2]
datos_tb[3]
```

Y tambi√©n por el nombre entre corchetes (doble corchete extrae la variable fuera del tibble, corchete simple en formato tibble):

```{r}
datos_tb["variable"]
datos_tb[["variable"]]

datos_tb["tercera falsa :)"]
datos_tb["2"]
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 5</strong>: obten de los paquetes `{dplyr}` y `{gapminder}` los conjuntos de datos tibble `starwars` y `gapminder`. Comprueba el n√∫mero de variables, de registros e imprime los datos</summary>

<!-- toc -->
- Soluci√≥n:

```{r}
# starwars
library(dplyr)
starwars
glimpse(starwars) # resumen de columnas
dim(starwars) # dimensiones

# gapminder
library(gapminder)
gapminder
glimpse(gapminder) # resumen de columnas
dim(gapminder) # dimensiones
```

<!-- tocstop -->
</details>

&nbsp;




## Tidy data {-}

:::: {.blackbox data-latex=""}

Scripts usados:

* [**script16.R**](https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script16.R): tidy data.  Ver en <https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script16.R>
::::

(haz click en las flechas para ver soluciones)


<details>
  <summary>üìù<strong>Ejercicio 1</strong>: convierte en _tidy data_ el siguiente `data.frame`.</summary>

```{r}
library(tibble)
library(tidyr)
tabla_tb <- tibble("trimestre" = c("T1", "T2", "T3"),
                   "2020" = c(10, 12, 7.5),
                   "2021" = c(8, 0, 9))
```

<!-- toc -->
- Soluci√≥n:

El problema es que las dos columnas con nombres de a√±o son en realidad valores que deber√≠an pasar a ser variables, as√≠ que deber√≠amos disminuir aplicar `pivot_longer()`

```{r}
# Aplicamos pivot_longer
tabla_tb %>% pivot_longer(cols = c("2020", "2021"),
                          names_to = "a√±o", values_to = "valores")
```

<!-- tocstop -->
</details>


&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 2</strong>: convierte en _tidy data_ el siguiente `data.frame`.</summary>

```{r}
tabla_tb <- tibble("a√±o" = c(2019, 2019, 2020, 2020, 2021, 2021),
                   "variable" = c("A", "B", "A", "B", "A", "B"),
                   "valor" = c(10, 9383, 7.58, 10839, 9, 32949))
```

<!-- toc -->
- Soluci√≥n:

El problema es que las filas que comparten a√±o son el mismo registro (pero con dos caracter√≠sticas que tenemos divididas en dos filas), as√≠ que deber√≠amos disminuir aplicar `pivot_wider()`

```{r}
# Aplicamos pivot_wider
tabla_tb %>% pivot_wider(names_from = "variable", values_from = "valor")
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 3</strong>: convierte en _tidy data_ la tabla `table5` del paquete `{tidyr}`.</summary>

<!-- toc -->
- Soluci√≥n:

Primero uniremos el siglo y las dos √∫ltimas cifras del a√±o para obtener el a√±o completo (guardado en `a√±o`)

```{r}
table5 %>%
  unite(a√±o, century, year, sep = "")
```

Tras ello deberemos separar el valor del ratio en denominador y numerador (ya que ahora hay dos valores en una celda), y convertiremos el tipo de dato en la salida para que sea n√∫mero.

```{r}
table5 %>%
  unite(a√±o, century, year, sep = "") %>%
  separate(rate, c("numerador", "denominador"), convert = TRUE)

```

<!-- tocstop -->
</details>




## Intro a tidyverse {-}

:::: {.blackbox data-latex=""}

Scripts usados:

* [**script19.R**](https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script19.R): intro a tidyverse.  Ver en <https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script19.R>
::::

(haz click en las flechas para ver soluciones)


<details>
  <summary>üìù<strong>Ejercicio 1</strong>: carga el conjunto de datos `starwars` y determina el tipo de variables, el n√∫mwero de filas y el n√∫mero de columnas.
  
<!-- toc -->
- Soluci√≥n:

```{r}
library(tidyverse)

# carga
starwars

# dimensiones
nrow(starwars)
ncol(starwars)
dim(starwars)

# Tipos de variables
glimpse(starwars)
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 2</strong>: del conjunto `starwars` encuentra todos los personajes cuyo peso est√© entre 60kg y 90kg. Imprime todas las columnas del filtro.
  
<!-- toc -->
- Soluci√≥n:

```{r}
# todas columnas
filtro <-
  starwars %>% filter(between(mass, 60, 90))
print(filtro, width = Inf)
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 3</strong>: a√±adido al filtro anterior, encuentra todos los personajes que adem√°s tengan los ojos que no sean azules.
  
<!-- toc -->
- Soluci√≥n:

```{r}
# todas columnas
filtro <-
  starwars %>%
  filter(between(mass, 60, 90) & eye_color != "blue")
print(filtro, width = Inf)
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 4</strong>: a√±adido al filtro anterior, encuentra todos los personajes que adem√°s tengan menos de 100 a√±os.
  
<!-- toc -->
- Soluci√≥n:

```{r}
# todas columnas
filtro <-
  starwars %>%
  filter(between(mass, 60, 90) & eye_color != "blue" &
           birth_year < 100)
print(filtro, width = Inf)
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 5</strong>: a√±adido al filtro anterior, selecciona solo las columnas `name, mass, eye_color, birth_year`
  
<!-- toc -->
- Soluci√≥n:

```{r}
# Solo name, mass, eye_color, birth_year
filtro %>% select(c(name, mass, eye_color, birth_year))
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 5</strong>: selecciona solo las columnas que contengan variables num√©ricas.
  
<!-- toc -->
- Soluci√≥n:

```{r}
starwars %>% select(where(is.numeric))
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 6</strong>: a√±adido a la selecci√≥n anterior, coloca los a√±os de nacimiento como primera columna y cambia los nombres a castellano.
  
<!-- toc -->
- Soluci√≥n:

```{r}
starwars %>%
  select(where(is.numeric)) %>%
  relocate(height, mass, .after = birth_year) %>%
  rename(edad = birth_year, altura = height, peso = mass)
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 7</strong>: calcula una nueva columna que indique el n√∫mero de naves que ha pilotado cada persona (escribe `? starwars` en consola para ver documentaci√≥n del fichero).
  
<!-- toc -->
- Soluci√≥n:

```{r}
starwars_numero_naves <- 
  starwars %>%
  mutate(n_naves = map_chr(starships, length))

# Imprimimos todas las columnas
print(starwars_numero_naves, width = Inf)

# Solo la columna a√±adida
starwars %>%
  transmute(n_naves = map_chr(starships, length))
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 8</strong>: con la columna anterior a√±adido, crea una nueva variable `TRUE/FALSE` que nos diga si ha conducido o no alguna nave, y filtra despu√©s solo aquellos personajes que han conducido alguna nave.
  
<!-- toc -->
- Soluci√≥n:

```{r}
# Nueva columna l√≥gica
starwars_numero_naves %>%
  mutate(conducir_nave = n_naves > 0) %>%
  filter(conducir_nave)
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 9</strong>: calcula el n√∫mero de pel√≠culas en las que han salido y ordena a los personajes de mayor a menor n√∫mero de pel√≠culas en las que ha aparecido
  
<!-- toc -->
- Soluci√≥n:

```{r}
starwars %>% # Calculamos primero el n√∫mero de pel√≠culas
  mutate(n_films = map_int(films, length)) %>%
  arrange(desc(n_films)) # Ordenamos de mayor a menor
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 10</strong>: selecciona 7 personajes al azar.
  
<!-- toc -->
- Soluci√≥n:

```{r}
# Una extracci√≥n aleatoria
starwars %>% slice_sample(n = 7)

# otra (que sale distinta, claro)
starwars %>% slice_sample(n = 7)
```

<!-- tocstop -->
</details>

&nbsp;


<details>
  <summary>üìù<strong>Ejercicio 11</strong>: selecciona los 5 personajes que en m√°s pel√≠culas han salido y los 5 que menos.
  
<!-- toc -->
- Soluci√≥n:

```{r}
# personajes que en m√°s pel√≠culas han salido (metiendo empates)
starwars  %>%
  mutate(n_films = map_int(films, length)) %>%
  slice_max(n_films, n = 5)

# personajes que en m√°s pel√≠culas han salido (sin empates)
starwars %>%
  mutate(n_films = map_int(films, length)) %>%
  slice_max(n_films, n = 5, with_ties = FALSE)

# personajes que en menos pel√≠culas han salido (metiendo empates)
starwars %>%
  mutate(n_films = map_int(films, length)) %>%
  slice_min(n_films, n = 5)

# personajes que en menos pel√≠culas han salido (sin empates)
starwars %>%
  mutate(n_films = map_int(films, length)) %>%
  slice_min(n_films, n = 5, with_ties = FALSE)
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 12</strong>: selecciona solo las columnas que se refieren a variables de color (ojos, piel, pelo) (con sufijo `"color"`)
  
<!-- toc -->
- Soluci√≥n:

```{r}
# Contiene "color" independientemente de que sea sufijo o prefijo
starwars %>% select(contains("color"))

# Contiene "color" como sufijo
starwars %>% select(ends_with("color"))
```

<!-- tocstop -->
</details>




## Profundizando tidyverse: encuestas electorales {-}

:::: {.blackbox data-latex=""}

Scripts usados:

* [**script20.R**](https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script20.R): profundizando tidyverse.  Ver en <https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script20.>

::::


Vamos a profundizar un poco en el uso de funciones `{tidyverse}` para el an√°lisis de <mark>**datos de encuestas**</mark>, <mark>**datos de Our World in Data**</mark> y <mark>**datos de Spotify**</mark>

En la denostada <mark>**wikipedia**</mark> se publican de forma **bastante completa** las encuestas electorales previas a las elecciones de un pa√≠s, en este caso de Espa√±a. El enlace donde est√°n los datos es <https://en.wikipedia.org/wiki/Opinion_polling_for_the_next_Spanish_general_election>


Lo que vamos a hacer primero <mark>**extraer la informaci√≥n de la web**</mark>, analizando desde `R` su c√≥digo HTML y qued√°ndonos con las <mark>**encuestas de 2021 y 2022**</mark>. Para ello haremos uso del paquete `{rvest}` (cargaremos tambi√©n `{tidyverse}`):

* `read_html()`: nos permite obtener el c√≥digo HTML de la web
* `html_elements()`: nos permite seleccionar elementos de dicho html
* `html_table()`: nos convierte una tabla HTML en un `tibble`.

De esta manera leeremos el HTML, localizaremos las tablas de datos y seleccionaremos solo las dos primeras (encuestas de 2022 y 2021).

```{r}
library(rvest)
library(tidyverse)
wiki <-
  paste0("https://en.wikipedia.org/wiki/Opinion_polling_for_the_next_Spanish_general_election")

# Leemos html
html <- read_html(wiki)

# Seleccionamos las tablas del HTML
tablas <- html_elements(html, ".wikitable")

# Obtenemos las dos primeras tablas: encuestas de 2022 y 2021
encuestas_2022 <- html_table(tablas[[1]])
encuestas_2022

encuestas_2021 <- html_table(tablas[[2]])
encuestas_2021
```

### Nombrar columnas {-}

Dado que la **mayor√≠a de las columnas** tienen como nombre de partido el logo del mismo, vamos a <mark>**renombrar las variables**</mark>.

```{r}
nombre_cols <-
  c("casa", "fechas", "muestra", "participacion", "PSOE", "PP",	"Vox",
    "UP", "Cs", "ERC", "MP", "JxCat",	"PNV",	"EHBildu", "CUP",
    "CC", "BNG", "NA+", "PRC", "EV", "ventaja")
names(encuestas_2022) <- names(encuestas_2021) <- nombre_cols
encuestas_2022
encuestas_2021
```

### Eliminar filas {-}

Tras la lectura sin salirnos de `R`, tenemos <mark>**dos tablas de encuestas electorales**</mark>, a las que les vamos a quitar la primera fila (vac√≠a) con `slice(-1)`.

```{r}
encuestas_2022 <- encuestas_2022 %>% slice(-1)
encuestas_2022
encuestas_2021 <- encuestas_2021 %>% slice(-1)
encuestas_2021
```

### A√±adir columna de a√±o {-}

En cada tabla vamos a <mark>**a√±adir una nueva columna que indique el a√±o**</mark>.

```{r}
encuestas_2022 <- encuestas_2022 %>% mutate(anno = 2022)
encuestas_2021 <- encuestas_2021 %>% mutate(anno = 2021)
```

### Juntar tablas {-}

Dado que queremos <mark>**un solo dataset**</mark> con las encuestas de ambos a√±os, vamos a juntar ambas tablas con `rbind()` para tener una sola tabla `encuestas`.

```{r}
encuestas <- rbind(encuestas_2022, encuestas_2021)
```


```{r}
DT::datatable(encuestas, options = list(pageLength = 10),
              caption = "Encuestas de 2021 y 2022")
```

### Convertir a num√©ricas {-}

Si te fijas los <mark>**valores de muchas variables son err√≥neos**</mark>, como tama√±o de la muestra o participaci√≥n: son de tipo texto cuando **deber√≠an ser num√©ricas**.

```{r}
encuestas
```

Para ello vamos antes a <mark>**eliminar las comas**</mark> `","` que separan los millares de los n√∫meros, con `gsub()`. Dicha orden nos permite <mark>**sustituir en un vector los caracteres**</mark> que queramos. Por ejemplo, de un vector de palabras vamos a cambiar la letra `a` por un punto `*`: primero le indicamos el patr√≥n a buscar, despu√©s el valor nuevo que le daremos, y por √∫ltimo la variable en la que lo vamos a aplicar.

```{r}
variable <- c("hola", "cama", "elefante", "cerrojo", "le√≥n", "gata")
gsub("a", "*", variable)
```

Con esta funci√≥n localizaremos las `","` de `muestra` para sustituirlas por `""` (sin nada), y lo mismo haremos con `"?"` en la variable `participacion` con los datos ausentes `"?"`.


```{r}
encuestas_depurado <-
  encuestas %>%
  # Quitamos "," como millares en n√∫meros
  mutate(muestra = gsub("?", "", gsub(",", "", muestra)),
         participacion = gsub("?", NA, participacion))
encuestas_depurado
```

Tras estos cambios, aunque muchas variables num√©ricas siguen siendo caracter, ya podemos aplicar la funci√≥n `as.numeric()`, que aplicaremos a todas las variables menos `casa` y `fechas`, con `mutate_at`, indic√°ndole con `vars()` primero las columnas a seleccionar (aquellas que no contengan la palabra `casa` ni `fechas`), y despu√©s la funci√≥n a aplicar.

```{r warning = FALSE}
encuestas_depurado <-
  encuestas_depurado %>%
  mutate_at(vars(!contains(c("casa", "fechas"))), as.numeric)
encuestas_depurado
```

### Convertir las fechas de campo {-}

Las <mark>**fechas del trabajo de campo**</mark> deben ser tratadas previamente:

* las fechas de tipo `"28 Dec‚Äì2 Jan"` (por ejemplo, de 2021) deberemos de convertirlas en dos fechas, `2021-12-28` y `2022-01-02`.

* las fechas de tipo `"12‚Äì14 Jan"` (por ejemplo, de 2021) deberemos de convertirlas en dos fechas, `2021-01-12` y `2021-01-14`.

* las fechas de tipo `"15 Jan"` (por ejemplo, de 2021), las convertiremos a dos fechas, `2021-01-15` y `2021-01-15`.

Para ello primero que vamos a hacer va a ser <mark>**separar las fechas por los guiones `-`**</mark> con `str_plit()` (que nos devolver√° una lista).

```{r}
fechas_intermedias <- str_split(encuestas_depurado$fechas, "‚Äì")
fechas_intermedias[1:6]
```

En cada lugar de la lista vemos que tenemos dos fechas en la mayor√≠a de casos: las pondremos en columnas `fecha_inicio` y `fecha_inicial`, devolviendo un `tibble` con `map_dfr` aplicado a la lista

```{r}
fechas_intermedias <-
  map_dfr(fechas_intermedias,
          function(x) { tibble("fecha_inicio" = x[1],
                               "fecha_final" = x[2]) })
fechas_intermedias
```

Los registros donde `fecha_final` est√° ausente significa que toma el mismo valor que la fecha de inicio, y as√≠ lo modificaremos.

```{r}
fechas_intermedias <-
  fechas_intermedias %>% 
  mutate(fecha_final = ifelse(is.na(fecha_final),
                              fecha_inicio, fecha_final))
fechas_intermedias
```

Las fechas que no tenga mes en `fecha_inicio`, asumiremos que es el mismo mes que `fecha_final`: si solo hay n√∫meros (dos o menos caracteres), obtenemos el mes de la `fecha_final` (√∫ltimos 3 caracteres) y lo pegamos al d√≠a.

```{r}
fechas_intermedias <-
  fechas_intermedias %>% 
  mutate(fecha_inicio =
           ifelse(nchar(fecha_inicio) <= 2,
                  paste(fecha_inicio,
                        paste0(rev(rev(unlist(str_split(fecha_final, "")))[1:3]),
                               collapse = "")), fecha_inicio))
fechas_intermedias
```

Esas fechas intermedias las vamos a√±adir como columnas y, peg√°ndole el a√±o, **vamos a convertirlas en datos de tipo fecha**. De todas las fechas nos vamos a quedar solo con la `fecha_final` (recolocando dicha columna tras el nombre de la casa encuestadora).

```{r}
library(lubridate)
encuestas_depurado <-
  bind_cols(encuestas_depurado,
            fechas_intermedias) %>%
  mutate(fecha_inicio = dmy(paste(fecha_inicio, anno)),
         fecha_final = dmy(paste(fecha_final, anno))) %>%
  select(-c(fechas, anno, fecha_inicio)) %>%
  relocate(fecha_final, .after = casa)
encuestas_depurado
```



### Limpiamos nombres de encuestas {-}

Por √∫ltimo, vamos <mark>**limpiar los nombres de las encuestas**</mark> eliminando la referencia a los enlaces de la wikipedia

```{r}
encuestas_depurado <-
  encuestas_depurado %>%
  # Limpiamos nombre encuestas
  mutate(casa = toupper(map_chr(str_split(casa, "\\["),
                                function (y) { y[1] } )))
```

```{r echo = FALSE}
DT::datatable(encuestas_depurado, options = list(pageLength = 10),
              caption = "Encuestas depuradas de 2021 y 2022")
```

                                          
### Consultas {-}

Una vez que tenemos los datos depurados vamos a <mark>**realizar algunas consultas sencillas**</mark> usando `{tidyverse}`.

<mark>**¬øCu√°les son las 10 encuestas con mayor tama√±o muestral?**</mark>

```{r}
encuestas_depurado %>% slice_max(muestra, n = 10)
```


<mark>**¬øCu√°les son las encuestas m√°s recientes?**</mark>

```{r}
encuestas_depurado %>% arrange(desc(fecha_final))
```

<mark>**¬øCu√°les son las 5 encuestas en las que el PSOE tiene mayor proyecci√≥n?**</mark>

```{r}
encuestas_depurado %>% slice_max(PSOE, n = 5)
```

<mark>**¬øCu√°l es la encuesta del CIS en la que el PP tiene mayor proyecci√≥n?**</mark>

```{r}
encuestas_depurado %>%
  filter(casa == "CIS") %>%
  slice_max(PP, n = 1)
```

<mark>**¬øCu√°l es el promedio de las encuestas del PSOE y PP por casa encuestadora?**</mark>

```{r}
encuestas_depurado %>%
  select(-fecha_final) %>%
  group_by(casa) %>%
  summarise(media_PSOE = mean(PSOE), media_PP = mean(PP)) %>%
  ungroup()
```

<mark>**¬øCu√°l es son las 3 casas encuestadoras m√°s sesgada hacia el PSOE (con mayor diferencia de promedio de PSOE vs PP)? ¬øY hacia el PP?**</mark>

```{r}
encuestas_depurado %>%
  select(-fecha_final) %>%
  group_by(casa) %>%
  summarise(media_PSOE = mean(PSOE), media_PP = mean(PP)) %>%
  ungroup() %>%
  mutate(diferencia = media_PSOE - media_PP) %>%
  slice_max(diferencia, n = 3)
```

```{r}
encuestas_depurado %>%
  select(-fecha_final) %>%
  group_by(casa) %>%
  summarise(media_PSOE = mean(PSOE), media_PP = mean(PP)) %>%
  ungroup() %>%
  mutate(diferencia = media_PP - media_PSOE) %>%
  slice_max(diferencia, n = 3)
```




## Visualizando datos: incursi√≥n a ggplot2 {-}

:::: {.blackbox data-latex=""}

Scripts usados:

* [**script21.R**](https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script21.R): incursi√≥n a ggplot2.  Ver en <https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script21.>

::::

(haz click en las flechas para ver soluciones)


<details>
  <summary>üìù<strong>Ejercicio 1</strong>: del conjunto `starwars` (del entorno de paquetes `{tidyverse}`), filtra solo los registros que no tenga ausente `NA` en las columnas `mass, height, eye_color` </summary>


<!-- toc -->
- Soluci√≥n:


```{r}
library(tidyverse)
# Eliminamos NA
starwars_filtro <- starwars %>% drop_na(c(mass, height, eye_color))
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 2</strong>: con ese conjunto filtrado dibuja un diagrama de puntos enfrentando `x = height` en el eje X e `y = mass` en el eje Y.</summary>


<!-- toc -->
- Soluci√≥n:


```{r}
ggplot(starwars_filtro, aes(x = height, y = mass)) +
  geom_point()
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 3</strong>: modifica el c√≥digo del gr√°fico anterior para asignar el tama√±o de los puntos en funci√≥n de la variable `mass`.</summary>


<!-- toc -->
- Soluci√≥n:


```{r}
ggplot(starwars_filtro,
       aes(x = height, y = mass, size = mass)) +
  geom_point()
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 4</strong>: modifica el c√≥digo del gr√°fico anterior para asignar el color en funci√≥n de su color de ojos guardado en `eye_color`. Antes procesa la variable para quedarte con colores reales: si hay dos colores, qu√©date con el primero; el color `"hazel"` p√°salo a `"brown"`; los colores `"unknown"` p√°salo a gris.</summary>


<!-- toc -->
- Soluci√≥n:


```{r}
# Transformar colores
starwars_filtro <-
   starwars_filtro %>%
    mutate(eye_color =
             case_when(eye_color == "blue-gray" ~ "blue",
                       eye_color == "hazel" ~ "brown",
                       eye_color == "unknown" ~ "gray",
                       eye_color == "green, yellow" ~ "green",
                       TRUE ~ eye_color))

# Visualizamos
ggplot(starwars_filtro,
       aes(x = height, y = mass, size = mass, color = eye_color)) +
  geom_point() +
  scale_color_manual(values =
                       c("black", "blue", "brown", "gray", "green",
                         "orange", "red", "white", "yellow"))
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 5</strong>: repite el gr√°fico anterior localizando ese dato con un peso extremadamente elevado (outlier), elim√≠nalo y vuelve a repetir la visualizaci√≥n.</summary>


<!-- toc -->
- Soluci√≥n:


```{r}
# Localizamos el valor
starwars_filtro %>% slice_max(mass, n = 5)
starwars_filtro %>% slice_max(mass, n = 5) %>% pull(name)
starwars_filtro <- starwars_filtro %>%
  filter(name != "Jabba Desilijic Tiure")

# Visualizamos
ggplot(starwars_filtro,
       aes(x = height, y = mass,
           size = mass, color = eye_color)) +
  geom_point() +
  scale_color_manual(values =
                       c("black", "blue", "brown", "gray", "green",
                         "orange", "red", "white", "yellow"))
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 6</strong>: repite el gr√°fico anterior eliminando la leyenda del tama√±o del punto y cambia el t√≠tulo de la leyenda del color de ojos a castellano. A√±ade adem√°s transparencia `alpha = 0.6` a los puntos.</summary>


<!-- toc -->
- Soluci√≥n:


```{r}
ggplot(starwars_filtro,
       aes(x = height, y = mass,
           size = mass, color = eye_color)) +
  geom_point(alpha = 0.6) +
  guides(size = "none") +
  scale_color_manual(values =
                       c("black", "blue", "brown", "gray", "green",
                         "orange", "red", "white", "yellow")) +
  labs(color = "color de ojos")
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 7</strong>: repite el gr√°fico modificando los t√≠tulos de los ejes (a castellano) y escribiendo t√≠tulo, subt√≠tulo y caption.</summary>


<!-- toc -->
- Soluci√≥n:


```{r}
ggplot(starwars_filtro,
       aes(x = height, y = mass,
           size = mass, color = eye_color)) +
  geom_point(alpha = 0.6) +
  guides(size = "none") +
  scale_color_manual(values =
                       c("black", "blue", "brown", "gray", "green",
                         "orange", "red", "white", "yellow")) +
  labs(color = "color de ojos",
       x = "altura (cm)", y = "peso (kg)",
       title = "STARWARS",
       subtitle = "Diagrama de puntos altura vs peso",
       caption = "Autor: Javier √Ålvarez Li√©bana | Datos: starwars")
```

<!-- tocstop -->
</details>


&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 8</strong>: repite el gr√°fico anterior explicitando los cortes en los ejes con `scale_x_continuous()` y `scale_y_continuous()`: el eje X de 60 a 240 (de 30 en 30 cada marca), el eje Y de 20 a 160 (de 20 en 20 cada marca).</summary>


<!-- toc -->
- Soluci√≥n:


```{r}
ggplot(starwars_filtro,
       aes(x = height, y = mass,
           size = mass, color = eye_color)) +
    geom_point(alpha = 0.6) +
    guides(size = "none") +
    scale_color_manual(values =
                           c("black", "blue", "brown", "gray", "green",
                             "orange", "red", "white", "yellow")) +
  scale_y_continuous(breaks = seq(20, 160, by = 20)) +
  scale_x_continuous(breaks = seq(60, 240, by = 30)) +
  labs(color = "color de ojos",
       x = "altura (cm)", y = "peso (kg)",
       title = "STARWARS",
       subtitle = "Diagrama de puntos altura vs peso",
       caption = "Autor: Javier √Ålvarez Li√©bana | Datos: starwars")
```

<!-- tocstop -->
</details>


&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 9</strong>: del conjunto de datos original, elimina los registros que tengan ausente la variable `sex`. Agrupa por dicha variable y contabiliza los personajes de cada sexo. Visual√≠zalo en un diagrama de barras vertical, con la escala de colores de `scale_fill_tableau()`, cambiando el nombre de leyenda y de ejes, y poni√©ndo t√≠tulos y subt√≠tulos.</summary>


<!-- toc -->
- Soluci√≥n:


```{r}
library(ggthemes)
starwars_filtro <- starwars %>% drop_na(sex)

# Vertical
ggplot(starwars_filtro %>% group_by(sex) %>% count(),
       aes(x = sex, y = n, fill = sex)) +
  geom_col() +
  scale_fill_tableau() +
  labs(fill = "Sexo",
       x = "Sexo", y = "N√∫mero de personajes",
       title = "STARWARS",
       subtitle = "Diagrama de barras verticales",
       caption = "Autor: Javier √Ålvarez Li√©bana | Datos: starwars")

# Horizontal
ggplot(starwars_filtro %>% group_by(sex) %>% count(),
       aes(x = sex, y = n, fill = sex)) +
  geom_col() +
  coord_flip() +
  scale_fill_tableau() +
  labs(fill = "Sexo",
       x = "Sexo", y = "N√∫mero de personajes",
       title = "STARWARS",
       subtitle = "Diagrama de barras vertical",
       caption = "Autor: Javier √Ålvarez Li√©bana | Datos: starwars")
```

<!-- tocstop -->
</details>

