```{r echo = FALSE}
library(knitr)

# Color text
colorize <- function(x, color) {
  
  if (knitr::is_latex_output()) {
    
    sprintf("\\textcolor{%s}{%s}", color, x)
    
  } else if (knitr::is_html_output()) {
    
    sprintf("<span style='color: %s;'>%s</span>", color, x)
    
  } else { x }
}
```

# Tidy vs messy data: daticos ordenados {#tidy}

:::: {.blackbox data-latex=""}

Scripts usados:

* [**script16.R**](https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script16.R): tidy data.  Ver en <https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script16.R>
::::

> Tidy datasets are all alike, but every messy dataset is messy in its own way (Hadley Wickham, Chief Scientist en RStudio)

Hasta ahora solo le hemos dado importancia al 춺qu칠췉 pero no al **춺c칩mo췉 manejamos los datos**. La <mark>**organizaci칩n de nuestros datos**</mark> es fundamental para que su preparaci칩n y explotaci칩n sea **lo m치s eficiente posible**: la limpieza y preprocesamiento puede llevarnos hasta el **80% del tiempo** en nuestro an치lisis si no se hace forma correcta [@DasuJohnson03].

```{r flujo-tidy-data2, echo = FALSE,  out.width = "60%", fig.align = "center", fig.cap = "Flujo deseable de datos seg칰n Hadley Wickham, extra칤da de <https://r4ds.had.co.nz/wrangle-intro.html>"}
knitr::include_graphics("./img/flujo_tidy_data.jpg")
``` 

El concepto <mark>**tidy data**</mark> fue introducido por **Hadley Wickham** [@Wickham14] como el <mark>**primer paso**</mark> del entorno de paquetes que posteriormente se fueron desarrollando bajo el nombre de `{tidyverse}`. Los conjuntos _tidy_ o <mark>**datos ordenados**</mark> tienen tres objetivos

* **Estandarizaci칩n** en su estructura.
* **Sencillez** en su manipulaci칩n.
* Listos para ser **modelizados y visualizados**.

Para ello, los <mark>**datos ordenados**</mark> o _tidy data_ deben cumplir:

1. Cada <mark>**variable en una columna**</mark>.
2. Cada <mark>**observaci칩n/registro/individuo en una fila diferente**</mark>.
3. Cada <mark>**celda con un 칰nico valor**</mark>.
4. Cada <mark>**conjunto o unidad observacional conforma una tabla**</mark>.
5. Si contamos con **m칰ltiples tablas**, debemos tener una **columna com칰n** en cada una que nos permita **cruzarlas**.

```{r tidy-data, echo = FALSE,  out.width = "80%", fig.align = "center", fig.cap = "Infograf칤a con datos ordenados (tidy data) extra칤da de <https://r4ds.had.co.nz/tidy-data.html>"}
knitr::include_graphics("./img/tidy_data.png")
``` 


## Entorno tidyverse

Conocemos ya un <mark>**formato amable**</mark> de almacenar los datos como son los `data.frame` de tipo `tibble`. Sin embargo muchas veces los datos no los tenemos en el formato deseado, o directamente queremos realizar algunas <mark>**transformaciones**</mark> en los mismos, ordenarlos, crear nuevas variables u obtener res칰menes num칠ricos. Para trabajar con los datos vamos a cargar `{tidyverse}`, un entorno de paquetes para el manejo de datos (ver m치s detalles en [Transformando los datos: incursi칩n al universo tidyverse](#tidyverse)).

```{r eval = FALSE}
install.packages("tidyverse") # SOLO la primera vez
```

```{r}
library(tidyverse)
```


```{r flujo-tidyverse-1, echo = FALSE, fig.align = 'center',  include = identical(knitr:::pandoc_to(), 'html'), fig.link = 'https://sporella.github.io/datos_espaciales_presentacion/#30', fig.cap = "Imagen extra칤da de <https://sporella.github.io/datos_espaciales_presentacion/#30>", out.width = '70%'}
knitr::include_graphics("img/flujo_tidyverse.png")
```

El <mark>**entorno `{tidyverse}`**</mark> es una de las **herramientas m치s importantes en el manejo de datos en `R`**, una **colecci칩n de paquetes** pensada para el manejo, la exploraci칩n, el an치lisis y la visualizaci칩n de datos, compartiendo una **misma filosof칤a y gram치tica**.


```{r flujo-tidyverse-2, echo = FALSE, fig.align = 'center',  include = identical(knitr:::pandoc_to(), 'html'), fig.link = 'https://www.storybench.org/getting-started-with-tidyverse-in-r/', fig.cap = "Imagen extra칤da de <https://www.storybench.org/getting-started-with-tidyverse-in-r/>", out.width = '90%'}
knitr::include_graphics("img/flujo_tidyverse_1.png")
```

* `{tidyr}`: para adecuar los datos a _tidy data_

* `{tibble}`: mejorando los `data.frame` para un manejo m치s eficiente 

* Paquete `{readr}` para una carga r치pida y eficaz de datos rectangulares (formatos `.csv`, `.tsv`, etc). Paquete `{readxl}` para importar archivos `.xls` y `.xlsx`. Paquete `{haven}` para importar archivos desde SPSS, Stata y SAS. Paquete `{httr}` para importar desde web. Paquete `{rvest}` para _web scraping_.

* `{dplyr}`: una gram치tica de manipulaci칩n de datos para facilitar su procesamiento.

* `{ggplot2}`: una gram치tica para la visualizaci칩n de datos.

* Paquete `{stringr}` para un manejo sencillo de cadenas de texto. Paquete `{forcast}` para un manejo de variables cualitativas (en `R` conocidas como factores). Paquete `{purrr}` para el manejo de listas y una programaci칩n funcional con las mismas. Paquete `{lubridate}` para el manejo de fechas.

Puedes ver su **documentaci칩n completa** en en <https://www.tidyverse.org/>.

&nbsp;

En este entorno, tendremos un <mark>**operador clave**</mark>: el operador <mark>**pipeline (%>%)**</mark>. Dicho operador lo debemos interpretar como una **flecha** que une nodos, y nos servir치 para <mark>**concatenar operaciones**</mark> sobre un conjunto de datos de forma <mark>**legible**</mark>. Por ejemplo, si tuvi칠semos tres funciones `first()`, `second()` y `third()`, la opci칩n m치s inmediata ser칤a anidar las tres funciones.

```{r eval = FALSE}
third(second(first(x)))
```

El anidamiento es **compacto** pero dificulta la lectura posterior del c칩digo: con el **pipeline %>%** podremos escribir (y leer) la <mark>**concetanci칩n de acciones de izquierda a derecha**</mark>:

```{r eval = FALSE}
first(x) %>% second(x) %>% third(x)
```


Dicho operador viene **heredado** del paquete `{magrittr}`, lo que hace que muchos paquetes de `{tidyverse}` dependan de 칠l. Para evitar esta dependencia (cuantos menos paquetes tengamos que cargar, mejor), desde la <mark>**versi칩n 4.1.0 de R**</mark>, disponemos de un operador pipeline **nativo** de `R`, el <mark>**operador |>**</mark> (disponible adem치s fuera del entorno `{tidyverse}`. En este manual seguiremos usando el operador `%>%`, pero es muy probable que en cada vez m치s c칩digos que busques por la red observes `|>` en detrimento de `%>%` (aunque el primero es m치s r치pido, m치s eficiente y sin necesidad de cargar otros paquetes).

## Messy data: valores en columnas en lugar de variables

Vamos a visualizar la tabla `table4a` del paquete `{tidyr}` (que ya lo tenemos cargado del entorno `{tidyverse}`).

```{r}
table4a
```

Si te fijas, tenemos una columna `country`, representando una variable con el nombre de los pa칤ses, **춰pero las otras columnas no representan cada una a una sola variable!** Ambas son la misma variable, solo que medida en a침os distintos (que deber칤a ser a su vez otra variable): **cada fila est치 representando dos observaciones** (1999, 2000) en lugar de un solo registro. Lo que haremos ser치 incluir una nueva columna llamada `year` que nos marque el a침o y otra `values` que nos diga el valor de la variable de inter칠s en cada uno de esos a침os.

Con la <mark>**funci칩n `pivot_longer`**</mark> del mencionada paquete le indicaremos lo siguiente:

- `cols`: el nombre de las columnas que vamos a **pivotar** (con comillas porque son n칰meros, no texto como nombre).
- `names_to`: el nombre de la columna a la que vamos a mandar los valores que figuran ahora en los nombres de las columnas.
- `values_to`: el nombre de la columna a la que vamos a mandar los valores.

```{r}
library(tidyr)
table4a %>% pivot_longer(cols = c("1999", "2000"),
                         names_to = "year",
                         values_to = "values")
```

Ahora tenemos un **registro por fila, una variable por columna y cada celda representa un 칰nico valor**. Este ejemplo de _messy data_ lo podemos encontrar muy a menudo cuando **construimos rangos de variables** pensando que es mejor tener una tabla m치s compacta (alargar la tabla a lo ancho en lugar de a lo largo). Es el caso de la tabla `relig_income`.

```{r}
relig_income
```

Salvo la primera, el resto de columnas tienen como **nombre los valores de una variable en s칤 misma** (ingresos). Para ordenar los datos vamos a razonar de la misma manera solo que ahora, en lugar de indicarle el nombre de todas las columnas que queremos usar de entrada, vamos a **indicarle de forma m치s corta la columna que NO queremos seleccionar**.

```{r}
# No necesitamos las comillas en el nombre de columnas salvo que tengan caracteres que no sean letras
relig_income %>% pivot_longer(-religion, names_to = "ingresos",
                              values_to = "frecuencia")
```

Lo que hacemos con `pivot_longer()` es **춺ampliar췉 la tabla, haci칠ndola m치s larga (m치s filas) pero con menos columnas**.


## Messy data: una observaci칩n guardada en varias filas

Vamos a visualizar ahora la tabla `table2` del paquete `{tidyr}`.

```{r}
table2
```

F칤jate en las cuatro primeras filas: los registros con el mismo a침o deber칤an ser el mismo, es la misma informaci칩n, deber칤a estar en la misma fila, pero est치 dividada en dos. Por un lado una fila para la variable `cases` y otra para `population`. Lo que haremos ser치 lo opuesto a antes: con `pivot_wider()` **춺ampliaremos췉 la tabla a lo ancho, haci칠ndola menos (menos filas) pero con m치s columnas**.

- `names_from`: el nombre de la columna de la que vamos a sacar las nuevas columnas que vamos a crear (`cases` y `population`).
- `values_from`: el nombre de la columna de la que vamos a sacar los valores.

```{r}
table2 %>% pivot_wider(names_from = type, values_from = count)
```

Ahora tenemos **cada registro en una fila**, que nos indica pa칤s-a침o-casos-poblaci칩n.

## Messy data: una celda con m칰ltiples valores

Por 칰ltimo vamos a visualizar la tabla `table3` del paquete `{tidyr}`.

```{r}
table3
```

En la variable `rate` hay guardados dos valores, separados por `/`, lo que hace que en **una celda no tiene un 칰nico valor sino dos**. La funci칩n `separate()` del paquete `{tidyr}` nos permitir치 <mark>**separar los m칰ltiples valores de la columna**</mark> `rate` simplemente indic치ndole el nombre de las nuevas columnas en el argumento `into = ...`, creando una nueva columna para cada uno de ellos.

```{r}
table3 %>% separate(rate, into = c("cases", "population"))
```

Por defecto lo que hace es **localizar como separador cualquier caracter que no sea alfa-num칠rico**. Si queremos un caracter concreto para dividir podemos indic치rselo expl칤citamente

```{r}
table3 %>% separate(rate, into = c("cases", "population"), sep = "/")
```

Si **usas un separador que no est치 en los datos** te devolver치 dichas columnas vac칤as ya que no ha podido dividirlas.

```{r warning = TRUE}
table3 %>% separate(rate, into = c("cases", "population"), sep = ".")
```


De la misma manera que podemos separar columnas <mark>**tambi칠n podemos unirlas**</mark>. Para ello vamos a usar la tabla `table5` del ya mencionado paquete. Con la funci칩n `unite()` vamos a unir el siglo (en `century`) y el a침o (en `year`), y al inicio le indicaremos como se llamar치 la nueva variable (`a침o_completo`).

```{r}
table5 %>% unite(a침o_completo, century, year)
```


Como pasaba en `separate()`, tiene un argumento de separador por defecto, en este caso `sep = "_"`. **Si queremos cambiarlo podemos hacerlo indic치ndoselo expl칤citamente**.

```{r}
table5 %>%
  unite(a침o_completo, century, year, sep = "")
```


## Consejos


**`r colorize("CONSEJOS", "#20935E")`**

&nbsp;


**`r colorize("Convertir variables al procesar", "#20935E")`**

Una opci칩n muy 칰til que podemos usar al aplicar la separaci칩n de los m칰ltiples valores es <mark>**convertir los datos al tipo adecuado**</mark>. Los datos unidos en `rate` eran caracteres ya que ten칤a el separador `/` (no pod칤an ser num칠ricos). Al separarlos, por defecto, aunque ahora ya son solo n칰meros, los separa como si fueran textos. Con `convert = TRUE` podemos indicarle que identifique el tipo de dato y lo convierta (f칤jate en la cabecera de las columnas ahora).

```{r}
table3 %>% 
  separate(rate, into = c("cases", "population"), convert = TRUE)
```


Dicha funci칩n tambi칠n puede ser usada para **dividir cifras, como por ejemplo el a침o**

```{r warning = TRUE}
table3 %>% separate(year,
                    into = c("siglo", "a침o"),
                    sep = 2)
```
  


## 游닇 Ejercicios

(haz click en las flechas para ver soluciones)


<details>
  <summary>游닇<strong>Ejercicio 1</strong>: convierte en _tidy data_ el siguiente `data.frame`.</summary>

```{r}
tabla_tb <- tibble("trimestre" = c("T1", "T2", "T3"),
                   "2020" = c(10, 12, 7.5),
                   "2021" = c(8, 0, 9))
```

<!-- toc -->
- Soluci칩n:

El problema es que las dos columnas con nombres de a침o son en realidad valores que deber칤an pasar a ser variables, as칤 que deber칤amos disminuir aplicar `pivot_longer()`

```{r}
# Aplicamos pivot_longer
tabla_tb %>% pivot_longer(cols = c("2020", "2021"),
                          names_to = "a침o", values_to = "valores")
```

<!-- tocstop -->
</details>


&nbsp;

<details>
  <summary>游닇<strong>Ejercicio 2</strong>: convierte en _tidy data_ el siguiente `data.frame`.</summary>

```{r}
tabla_tb <- tibble("a침o" = c(2019, 2019, 2020, 2020, 2021, 2021),
                   "variable" = c("A", "B", "A", "B", "A", "B"),
                   "valor" = c(10, 9383, 7.58, 10839, 9, 32949))
```

<!-- toc -->
- Soluci칩n:

El problema es que las filas que comparten a침o son el mismo registro (pero con dos caracter칤sticas que tenemos divididas en dos filas), as칤 que deber칤amos disminuir aplicar `pivot_wider()`

```{r}
# Aplicamos pivot_wider
tabla_tb %>% pivot_wider(names_from = "variable", values_from = "valor")
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>游닇<strong>Ejercicio 3</strong>: convierte en _tidy data_ la tabla `table5` del paquete `{tidyr}`.</summary>

<!-- toc -->
- Soluci칩n:

Primero uniremos el siglo y las dos 칰ltimas cifras del a침o para obtener el a침o completo (guardado en `a침o`)

```{r}
table5 %>%
  unite(a침o, century, year, sep = "")
```

Tras ello deberemos separar el valor del ratio en denominador y numerador (ya que ahora hay dos valores en una celda), y convertiremos el tipo de dato en la salida para que sea n칰mero.

```{r}
table5 %>%
  unite(a침o, century, year, sep = "") %>%
  separate(rate, c("numerador", "denominador"), convert = TRUE)

```

<!-- tocstop -->
</details>




