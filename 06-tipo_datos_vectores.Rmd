```{r echo = FALSE}
library(knitr)

# Color text
colorize <- function(x, color) {
  
  if (knitr::is_latex_output()) {
    
    sprintf("\\textcolor{%s}{%s}", color, x)
    
  } else if (knitr::is_html_output()) {
    
    sprintf("<span style='color: %s;'>%s</span>", color, x)
    
  } else { x }
}
```

# Vectores {#vectores}

Tras las lecciones anteriores, los ejercicios planteados y lo que hayas jugueteado por tu cuenta, deber√≠amos saber usar ya `R` como una calculadora. Vamos a ir m√°s all√°: ¬øy si en lugar de tener un solo elemento, por ejemplo `a <- 1`, tenemos una <mark>**colecci√≥n de elementos**</mark>? En este cap√≠tulo vamos a ver un cl√°sico de cualquier lenguaje de programaci√≥n: los <mark>**vectores o arrays**</mark>, que no son m√°s que una <mark>**concatenaci√≥n**</mark> de elementos del mismo tipo. De hecho un n√∫mero individual (por ejemplo, `1`) es en realidad un vector de longitud uno (un solo elemento).

Si sabes algo de matem√°ticas, un vector es lo que solemos representar como $\overrightarrow{x} = \left[1, 2, 3 \right]$, pero no te preocupes si nunca has visto esta forma de representarlos. Vamos a empezar de cero.


## Vectores num√©ricos


La forma m√°s sencilla de **crear un vector** en `R` es con el comando `c()` (de **concatenar elementos**), y basta con introducir sus elementos entre par√©ntesis, y separados por comas. Vamos a crear el vector con los tres primeros n√∫meros naturales pares (el 0 no es natural, no seas b√°rbaro/a).

```{r}
z <- c(2, 4, 6)
z
```

Como ves ahora en el **environment (entorno, arriba a la derecha) tenemos una colecci√≥n de elementos**, tres en concreto, guardados en una misma variable `z`. La longitud de un vector se puede calcular con el comando `length()` (nos devolver√° el n√∫mero de elementos de la variable que le pasemos como argumento).

```{r}
length(z)
```

Adem√°s podemos **concatenar a su vez vectores**: vamos a concatenar el vector `z` consigo mismo, y a√±adi√©ndole al final un 8.

```{r}
c(z, z, 8)
```

Esta √∫ltima concatenaci√≥n lo que nos ha dado son, primero, los tres pares que ya ten√≠amos en `z`, despu√©s de nuevo los tres primeros pares, y por √∫ltimo un 8.


## Secuencias num√©ricas con un patr√≥n

Muchas veces nos gustar√≠a **crear vectores de una forma mucho m√°s r√°pida**. Supongamos que queremos el vector de los primeros 21 n√∫meros naturales. Si construy√©ramos el vector como antes, tendr√≠amos que ejecutar el comando `c(1, 2, 3, 4, 5, ...)` hasta llegar al n√∫mero 21. ¬øUn poco largo, no?

Hay un atajo: el comando `seq()` nos permite crear una <mark>**secuencia desde un elemento inicial hasta un elemento final**</mark>, avanzando de uno en uno.

```{r}
seq(1, 21) # secuencia desde 1 hasta 21 de uno en uno
```

Es importante que no perdamos el foco de que <mark>**programar es similar a escribir en un idioma**</mark>, por lo que si hay algo que se puede decir de una forma m√°s limpia y que se entienda mejor, ¬øpor qu√© no usarlo? Siempre que queramos definir secuencias entre dos n√∫meros naturales (por ejemplo, entre `1` y un valor `n`), cuya distancia entre elementos consecutivos sea uno, el comando `1:n` nos devuelve lo mismo que la orden `seq(1, n)`. Adem√°s, si el elemento inicial es mayor que el final, `R` entender√° solo que la secuencia la queremo decreciente.

```{r}
n <- 21
1:n # secuencia desde 1 hasta n (21) de uno en uno
n:1 # secuencia decreciente
```


&nbsp;

Tambi√©n podemos definir **otro tipo de distancia entre dos elementos consecutivos** (conocido como **paso de discretizaci√≥n**), por ejemplo de 0.5 en 0.5.

```{r}
seq(1, 10, by = 0.5) # secuencia desde 1 a 10 de 0.5 en 0.5
```

Otras veces nos interesar√° definir una secuencia entre un valor inicial y un valor final, pero nos da igual la distancia entre cada elemento: solo nos importa que tenga un n√∫mero concreto de elementos (y que sea `R` el que decida la distancia entre elementos consecutivos para conseguirlo).

```{r}
seq(1, 50, l = 11) # secuencia desde 1 a 50 de longitud 11
```

&nbsp;

Otro atajo que podemos usar para definir secuencias de n√∫meros con un patr√≥n es definir <mark>**vectores de elementos repetidos**</mark>, por ejemplo un vector lleno de ceros. La funci√≥n `rep()` nos permite repetir un elemento un n√∫mero fijado de veces.

```{r}
rep(0, 7) # vector de 7 ceros
```

No solo podemos repetir un n√∫mero sino que podemos repetir vectores enteros.

```{r}
rep(c(0, 1, 2), 4) # repetimos el vector c(0, 1, 2) 4 veces
```

Esa repetici√≥n adem√°s podemos definirla tambi√©n de forma **intercalada**: en lugar de repetir `c(0, 1, 2)` cuatro veces seguidas, queremos cuatro 0, despu√©s cuatro 1, y despu√©s cuatro 2.

```{r}
rep(c(0, 1, 2), each = 4) # cuatro 0, luego cuatro 1, luego cuatro 2
```


## Vectores de caracteres (texto)

Un error com√∫n es asociar el concepto de vectores solo a n√∫meros: un <mark>**vector es una colecci√≥n o concatenaci√≥n de elementos del mismo tipo**</mark> pero no tienen porque ser necesariamente n√∫meros. Vamos a crear una frase de ejemplo, un vector de 4 elementos de tipo texto (en `R` se llaman `char`): `"Mi"`, `"nombre"`, `"es"` `"Javier"`.

Como ves las variables de tipo `char` o `character` van entre comillas dobles, ya que es un <mark>**cadena de texto**</mark>.

```{r}
mi_nombre <- c("Mi", "nombre", "es", "Javier")
mi_nombre
```

Ya tenemos nuestro primer vector de texto de longitud 4. Las **cadenas de texto** son un tipo especial de dato, con los que obviamente no podremos hacer operaciones aritm√©ticas como la suma o la media, pero si podemos hacer operaciones propias de cadenas de texto como puede ser la funci√≥n `paste()`. Dicha funci√≥n nos permite convertir un vector de 4 palabras en una frase, decidiendo que caracter queremos que vaya entre palabra con el argumento `collapse =`.


```{r}
paste(mi_nombre, collapse = "") # todo junto
paste(mi_nombre, collapse = " ") # separados por un espacio
paste(mi_nombre, collapse = ".") # separados por un punto .
```

Si queremos pegar los elementos de la cadena de texto sin ning√∫n tipo de caracter, existe una forma m√°s abreviada y limpia de ejecutar la orden `paste(mi_nombre, collapse = "")`, usando la funci√≥n `paste0()` 

```{r}
paste0(mi_nombre) # todo junto sin nada separando
```

Esta funci√≥n es muy √∫til si queremos definir variables de texto que compartan por ejemplo un prefijo (`variable_1`, `variable_2`, ...)

```{r}
paste0("variable", 1:7) # a la palabra ¬´variable¬ª le pegamos los n√∫meros del 1 al 7
paste("variable", 1:7, sep = "_") # separado por una barra baja
```

### Paquete glue

  
Otra **forma m√°s intuitiva de trabajar con textos y variables num√©ricas** es usar el paquete `{glue}`, que nos permite pegar cadenas de texto a variables num√©ricas de **forma simb√≥lica**.

```{r eval = FALSE}
install.packages("glue")
library(glue)
```

```{r eval = FALSE}
edad <- 10:15 # edades
glue("La edad es de {edad} a√±os")
```

```{r echo = FALSE}
library(glue)
edad <- 10:15 # edades
unidades <- "a√±os"
glue("La edad es de {edad} {unidades}")
```

Tambi√©n podemos hacer uso de dicha funci√≥n sin tener los valores num√©ricos previamente guardados en variables.

```{r}
# Otra forma sin definir variables a priori
glue("La edad es de {10:15} a√±os")
```

Ya sabemos trabajar con textos :) 

¬øY si queremos **pasar todo a may√∫scula**? ¬øO **todo a min√∫scula**? ¬øY si queremos **sustituir un caracter (por ejemplo `.`) por otro en todos los elementos**? `R` tambi√©n nos proporciona algunas funciones muy sencillas (del paquete `{base}`) de usar para dichas tareas. Aqu√≠ un ejemplo de algunas de ellas.

```{r}
texto <- c("Hola.", "qu√©", "ase?", "todo", "bien.", "y yo",
           "que", "ME", "ALEGRO")
toupper(texto) # todo a may√∫scula
tolower(texto) # todo a min√∫scula
```

El paquete `{base}` tambi√©n nos permite buscar y reemplazar patrones concretos en cadenas de texta (por ejemplo, sustituir toda letra ¬´o¬ª por el caracter ¬´*¬ª).

```{r}
gsub("o", "*", texto) # toda "o" en el texto ser√° sustituida por *
```

&nbsp;


## Vectores l√≥gicos (TRUE/FALSE)

- [X] Variables num√©ricas (individuales)
- [X] Vectores de n√∫meros
- [X] Vectores de caracteres
- [ ] Vectores l√≥gicos

Veamos un √∫ltimo tipo de vectores importante en todo lenguaje de programaci√≥n: los <mark>**vectores de valores l√≥gicos**</mark>. Un **valor l√≥gico** puede tomar tres valores:

* `TRUE` (guardado internamente como un `1`).
* `FALSE` (guardado internamente como un `0`).
* `NA` (dato ausente, son las siglas de _not available_, cuando pretendemos aplicar una comparaci√≥n a un dato ya de por si ausente).

Estos valores son resultado de evaluar <mark>**condiciones l√≥gicas**</mark>. Por ejemplo, imaginemos que definimos un vector de n√∫meros `x <- c(1.5, -1, 2, 4, 3, -4)`. ¬øQu√© numeros del vector son menores que 2? Basta con que ejecutemos la orden `x < 2`, que nos devolver√° `TRUE/FALSE` en cada hueco, en funci√≥n de si cumple (`TRUE`) o no (`FALSE`) la condici√≥n pedida.

```{r}
x <- c(1.5, -1, 2, 4, 3, -4)
x < 2
```

El primer, segundo y sexto elemento del vector son los √∫nicos elementos (estrictamente) menores que `2`, de ah√≠ que en el primer, segundo y sexto elemento aparezca un `TRUE` y en el resto un `FALSE`. Es **importante** recordar que al **evaluar una condici√≥n l√≥gica sobre un vector** de longitud `n`, la **salida sigue siendo un vector** de longitud `n` pero con valores l√≥gicos.

Dicha condici√≥n l√≥gica puede hacerse con otros operadores como `<=`, `>` o `>=`. 

```{r}
x <= 2
```

```{r}
x > 2
```

```{r}
x >= 2
```

&nbsp;

Tambi√©n podemos **comparar si es igual a otro elemento**, para lo que usaremos el operador `==`, pudiendo usar tambi√©n su opuesto `!=` (¬´distinto de¬ª).

```{r}
x == 2
```

```{r}
x != 2
```

Las **condiciones pueden ser combinadas**, principalmente de dos maneras:

- **Intersecci√≥n**: todas las condiciones concatenadas se deben cumplir (conjunci√≥n `y`, operador `&`) para devolver un `TRUE`.

- **Uni√≥n**: basta con que una de las condiciones concatenadas se cumpla (conjunci√≥n `o`, operador `|`) para devolver un `TRUE`.

Por ejemplo, vamos a calcular qu√© elementos del vector `c(1.5, -1, 2, 4, 3, -4)` sean menores que 3 pero (y) mayores que 0, y los elementos menores que 2 o mayores que 3.

```{r}
x <- c(1.5, -1, 2, 4, 3, -4)
x < 3 & x > 0 # Solo los que cumplen ambas condiciones
x < 2 | x > 3 # Los cumplen al menos una de ellas
```



## Consejos


**`r colorize("CONSEJOS", "#20935E")`**

&nbsp;

**`r colorize("Expresiones regulares", "#20935E")`**

Dentro del entorno de paquetes `{tidyverse}`, el paquete `{stringr}` permite un manejo m√°s complejo de cadenas de texo (como el uso de expresiones regulares).

```{r stringr2, echo = FALSE, fig.cap = "Paquete stringr para manejar cadenas de texto m√°s complejas"}
knitr::include_graphics("./img/stringr.png")
```

&nbsp;


## üìù Ejercicios

(haz click en las flechas para ver soluciones)

<details>
  <summary>üìù<strong>Ejercicio 1</strong>: define un vector que contenga los n√∫meros 1, 10, -1 y 2, y gu√°rdalo en una variable llamada `vector_num`. </summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
# Vector de n√∫meros
vector_num <- c(1, 10, -1, 2)
vector_num
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 2</strong>: crea un vector con las palabras "Hola", "me", "llamo" (y tu nombre y apellidos), y pega luego sus elementos de forma que la frase est√© correctamente escrita en castellano. Tras hacerlo, a√±ade "y tengo 30 a√±os". </summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
# Definiendo el vector
vector_char <- c("Hola", "me", "llamo", "Javier",
                 "√Ålvarez", "Li√©bana")

# Pegamos
paste(vector_char, collapse = " ")

# A√±adimos frase
paste0(paste(vector_char, collapse = " "), " y tengo 30 a√±os.")
```

<!-- tocstop -->
</details>

&nbsp;



