```{r echo = FALSE}
library(knitr)

# Color text
colorize <- function(x, color) {
  
  if (knitr::is_latex_output()) {
    
    sprintf("\\textcolor{%s}{%s}", color, x)
    
  } else if (knitr::is_html_output()) {
    
    sprintf("<span style='color: %s;'>%s</span>", color, x)
    
  } else { x }
}
```

# (PART) Conceptos b치sicos {-}

# Tipos de datos {#tipos-datos}

:::: {.blackbox data-latex=""}

Scripts usados:

* [**script05.R**](https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script05.R): tipos de datos y funciones usadas con ellos.  Ver en <https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script05.R>

::::

&nbsp;

Tras los ejercicios planteados en la lecci칩n anterior y lo que hayas jugueteado por tu cuenta, deber칤amos saber m치s o menos usar `R` como una calculadora, definiendo variables que nos guardan n칰meros, como `a <- 1`. Vamos a ir m치s all치: <mark>**쯘xisten variables m치s all치 de los n칰meros?**</mark> En este cap칤tulo vamos a empezar a familiarizarnos con los <mark>**tipos de datos**</mark> que podemos necesitar. Piensa por ejemplo en los datos guardados de una persona:

* La edad ser치 un <mark>**n칰mero (sin decimales)**</mark>
* Su peso o estatura ser치 otro <mark>**n칰mero (ahora con decimales)**</mark>.
* Su nombre ser치 una <mark>**cadena de texto**</mark>.
* Su fecha de nacimiento ser치 precisamente eso, una <mark>**fecha**</mark>.
* A la pregunta 춺쯘st치 usted soltero/a?췉 la respuesta ser치 lo que llamamos una <mark>**variable binaria o l칩gica**</mark>: una variable que solo puede valer `TRUE` (si est치 soltero/a) y `FALSE` (en otro caso).

Existen **m치s tipos** (por ejemplo, n칰meros complejos) pero con estos nos valdr치 de momento.


## Variables num칠ricas {#numericas}

- [X] Variables num칠ricas (individuales)
- [ ] Variables de caracteres
- [ ] Variables l칩gicas
- [ ] Variables de tipo fecha

Probablemente el dato **m치s sencillo y obvio** de entender sean los datos num칠ricos, datos que ya hemos usado en nuestros primeros pasos como calculadora.

```{r}
a <- 1
b <- 2
a + b
```

En el c칩digo anterior, tanto `a` como `b`, como la suma `a + b`, son de <mark>**tipo num칠rico**</mark>, algo que podemos comprobar con la funci칩n `class()` (nos devuelve _numeric_).

```{r}
# Clase de las variables
class(a)
class(b)
class(a + b)
```

Tambi칠n podemos comprobar su naturaleza con `typeof()`, que nos devuelve la naturaleza del dato tal cual es guardada en `R`.

```{r}
# Topolog칤a interna
typeof(a)
typeof(b)
typeof(a + b)
```

Aunque no es especialmente relevante profundizar en ello de momento, f칤jate que ambas 칩rdenes combinadas nos dicen que las variables son de tipo num칠rico pero concretamente de tipo <mark>**double**</mark>: dichas variables son entendidas internamente como n칰meros con decimales (aunque no los veamos), lo que en **matem치ticas se llaman n칰meros reales** (por curiosidad: el t칠rmino _double_ viene de lenguajes de programaci칩n antiguos como `C`, que significa 춺doble precisi칩n췉, para indicarle que reserve 8 bytes - 64 bits - de memoria). Durante el curso no distinguiremos entre distintos tipos de n칰meros, para nosotros ser치n siempre de clase _numeric_ y de tipo _double_, pero podr칤amos definir n칰meros enteros o _integer_ (sin decimales, ahorrando huecos en memoria).

```{r}
# Dato num칠rico (entero)
a <- 1L
class(a)
typeof(a)
```

Con los <mark>**datos num칠ricos**</mark> podemos realizar todas las <mark>**operaciones**</mark> que se nos ocurrir칤a hacer en una **calculadora**, como sumar (`+`), restar (`-`), multiplicar (`*`), dividir (`/`), ra칤z cuadrada (`sqrt()`), valor absoluto (`abs()`), elevar al cuadrado  (`^2`), elevar al cubo (`^3`), etc.


```{r}
# Definimos dos variables num칠ricas
a <- 1
b <- -2

# Suma y resta
a + b
a - b

# Multiplicaci칩n y divisi칩n
a * b
a / b

# Ra칤z cuadrada
sqrt(a)

# Potencias
a^2
b^3
```



## Variables de tipo caracter (texto) {#caracter}

- [X] Variables num칠ricas (individuales)
- [X] Variables de caracteres
- [ ] Variables l칩gicas
- [ ] Variables de tipo fecha

Pero no solo de n칰meros viven los datos: imagina que adem치s de la edad de una persona queremos guardar su nombre.

```{r}
edad <- 32
nombre <- "Javier"

class(edad)
typeof(edad)

class(nombre)
typeof(nombre)
```

F칤jate que ahora tenemos en `nombre` una variable de tipo _character_, es decir, una cadena de texto (conocido en otros lenguajes como _string_ o _char_): **letras y caracteres entre comillas**. 

### Nuestra primera funci칩n: paste


Las <mark>**cadenas de texto**</mark> son un tipo especial de dato, con los que obviamente no podremos hacer operaciones aritm칠ticas, pero si podemos hacer operaciones propias de cadenas de texto como puede ser la <mark>**funci칩n `paste()`**</mark>. Dicha funci칩n nos permite **pegar dos cadenas de caracteres**, decidiendo que caracter queremos que vaya entre palabra con el argumento `sep =`.

```{r}
nombre <- "Javier"
apellido <- "츼lvarez"
paste(nombre, apellido, sep = "") # todo junto
paste(nombre, apellido, sep = " ") # separados por un espacio
paste(nombre, apellido, sep = ".") # separados por un punto .
```

Si queremos pegar cadenas de texto sin ning칰n tipo de caracter, existe una forma m치s abreviada y limpia de ejecutar la orden, usando la <mark>**funci칩n `paste0()`**</mark>

```{r}
# Son equivalentes
paste(nombre, apellido, sep = "") # todo junto
paste0(nombre, apellido) # todo junto sin nada separando
```

Cuando hemos ejecutado `paste()` estamos ejecutando lo que se conoce como una <mark>**funci칩n**</mark>: una palabra reservada que representa un **conjunto de 칩rdenes**, y que se ejecuta a partir de unos <mark>**argumentos de entrada**</mark>. En el caso de la funci칩n `paste()`, los argumentos ser치n las cadenas de texto que queremos copiar, y un **argumento opcional** llamado `sep`, que podemos darle un valor en concreto o dejarlo sin especificar. Lo que har치 `R` ser치 tomar su <mark>**valor por defecto**</mark> igual a `sep = " "` (por defecto, la funci칩n `paste()` pega cadenas de texto con un espacio entre ellas). Prueba a ejecutar `? paste` en consola para ver las opciones en el **panel de ayuda**.

```{r}
# Son equivalentes
paste(nombre, apellido, sep = " ")
paste(nombre, apellido)
```

### Nuestro primer paquete: glue

  
Otra **forma m치s intuitiva de trabajar con textos y variables num칠ricas** es usar el paquete `{glue}`, que nos permite pegar cadenas de texto a variables num칠ricas de **forma simb칩lica**.

```{r eval = FALSE}
install.packages("glue") # solo la primera vez
```

```{r}
library(glue)
```

Recuerda que `install.packages()` es solo necesario la primera que 춺compramos el libro췉: nos bajamos una serie de archivos a nuestro ordenador. Una vez que hemos comprado el libro, cada vez que queramos usarlo bastar치 con indicarle que nos traiga ese libro concreto con `library()`.

El paquete `{glue}` nos permite pegar de una forma mucho m치s legible cadenas de texto

```{r}
# Ejemplo 1
edad <- 32
glue("La edad es de {edad} a침os")
paste("La edad es de", edad, "a침os") # equivalente

# Ejemplo 2
edad <- 32
unidades <- "a침os"
glue("La edad es de {edad} {unidades}")
```

Tambi칠n podemos hacer uso de dicha funci칩n sin tener los valores num칠ricos previamente guardados en variables.

```{r}
# Otra forma sin definir variables a priori
glue("La edad es de {32} a침os")
```

&nbsp;


## Variables l칩gicas (TRUE/FALSE) {#logicas}

- [X] Variables num칠ricas (individuales)
- [X] Variables de caracteres
- [X] Variables l칩gicas
- [ ] Variables de tipo fecha

Probablemente el tipo de datos m치s importante en todo lenguaje de programaci칩n son las <mark>**variables l칩gicas**</mark>. Un **valor l칩gico** puede tomar **dos valores** (en realidad pueden tomar un tercer valor, `NA`, las siglas de _not available_ para representar datos ausentes, pero lo veremos m치s adelante):

* `TRUE` (guardado internamente como un `1`).
* `FALSE` (guardado internamente como un `0`).

Este tipo de variables, tambi칠n conocidas como <mark>**variables binarias (solo dos valores) o booleanas**</mark>, son la base de la programaci칩n ya que cada bit de nuestro ordenador puede guardar un `1` o un `0`.

```{r}
soltero <- TRUE # 쮼s soltero? --> S칈
carnet_conducir <- FALSE # 쯊iene carnet de conducir? --> NO

class(soltero)
typeof(soltero)

class(carnet_conducir)
typeof(carnet_conducir)
```

Ahora nuestas variables son guardadas como _logical_, y pueden tomar los valores `TRUE/FALSE`, aunque internamente son guardados como `1/0`. Es importante entender que <mark>**no son variables de texto**</mark>:

* `"TRUE"` es un texto (internamente id칠ntico a `rojo` o `azul`)
* `TRUE` es una variable l칩gica

```{r error = TRUE}
# Texto
texto <- "TRUE"
texto + 1

# L칩gica
logica <- TRUE
logica + 1
```

Estos valores suelen ser resultado de evaluar <mark>**condiciones l칩gicas**</mark>. Por ejemplo, imaginemos que queremos comprobar si una persona est치 soltero o no, y si tiene carnet de conducir o no. Basta con que ejecutemos la orden `soltero == TRUE`, que nos devolver치 `TRUE` si est치 soltero, y `FALSE` en caso contrario. De igual manera podremos hacer `carnet_conducir == TRUE`. <mark>**IMPORTANTE**</mark>: cuando queremos **comparar si un elemento es igual a otro**, usaremos el operador de comparaci칩n `==`, pudiendo usar tambi칠n su opuesto `!=` (춺distinto de췉).


```{r}
soltero == TRUE
soltero != TRUE # igual que soltero == FALSE
carnet_conducir == TRUE
carnet_conducir != TRUE
```

Por el mismo razonamiento podemos <mark>**comparar si una variable num칠rica o de tipo caracter**</mark> es igual o distinto a un valor dado, incluso para las num칠ricas podemos **comparar si son menores o mayores** que un n칰mero. 

쯊iene la persona menos de 32 a침os? 쯊iene justo 32 a침os? 쯊iene 32 a침os o m치s?

```{r}
edad < 32
edad == 32
edad >= 32
```

쯃a persona se llama Carlos?

```{r}
nombre == "Carlos"
```

F칤jate que para comparaciones tenemos 춺igual a췉 `==` frente distinto `!=`, pero tambi칠n comparaciones de orden como `<=`, `>` o `>=`. Las <mark>**condiciones l칩gicas pueden ser combinadas**</mark>, principalmente de dos maneras:

- **Intersecci칩n**: todas las condiciones concatenadas se deben cumplir (conjunci칩n `y`, operador `&`) para devolver un `TRUE`.

- **Uni칩n**: basta con que una de las condiciones concatenadas se cumpla (conjunci칩n `o`, operador `|`) para devolver un `TRUE`.

Por ejemplo, podr칤amos preguntarnos si la persona tiene m치s de 32 a침os y est치 soltero (AMBAS deben cumplirse).

```{r}
edad > 32 & soltero == TRUE
# Equivalente (al ser soltero un valor ya de por si l칩gico)
edad > 32 & soltero
```

Vemos que el resultado es `FALSE` ya que solo se cumple una de las condiciones: devolver칤a `TRUE` si preguntamos si tiene m치s de 30 a침os y est치 soltero, o si solo pedimos una de las dos condiciones (쯘st치 soltero y/o tiene m치s de 32 a침os?).

```{r}
edad > 32 | soltero # nos sirve con que alguna se cumpla
edad > 32 & soltero # deben cumplirse ambas
edad > 30 & soltero # deben cumplirse ambas
```

## Variables de tipo fecha {#fechas}

- [X] Variables num칠ricas (individuales)
- [X] Variables de caracteres
- [X] Variables l칩gicas
- [X] Variables de tipo fecha

Por 칰ltimo, vamos a ver un tipo de datos muy especial: los <mark>**datos de tipo fecha**</mark>. Una fecha podr칤a ser a priori una simple cadena de texto `"2021-04-21"` pero podemos usar la funci칩n `as.Date()` para que `R` entienda que esa cadena de texto representa un instante temporal. F칤jate la diferencia entre una fecha en texto y una fecha con `as.Date()`.

```{r error = TRUE}
# Cadena de texto
fecha_char <- "2021-04-21"
fecha_char + 1

# Fecha, mostrada como un texto pero guardada internamente como un n칰mero
fecha_date <- as.Date(fecha_char, format = "%Y-%m-%d")
fecha_date + 1
```

En el momento en que convertimos la cadena de texto a fecha, aunque se visualice como un texto, internamente es un n칰mero, por lo que podemos restar fechas (d칤as entre ambas), **podemos sumar n칰meros a fechas (fecha d칤as despu칠s)**, etc. Como ya hemos dicho, **las fechas y momentos temporales no ser치n meras cadenas de caracter sino que tienen clases especiales asociadas**. Las fechas ser치n guardadas internamente como el **n칰mero de d칤as transcurridos desde el 1 de enero de 1970**, y las horas como **n칰mero de segundos desde el 1 de enero de 1970** (para la clase `POSIXct`) o una lista de segundos, minutos y horas (para la clase `POSIXlt`).

쮺칩mo <mark>**obtener autom치ticamente la fecha de hoy**</mark>? La funci칩n `Sys.Date()` nos devuelve directamente la fecha y hora en el momento de la ejecuci칩n de la orden.

```{r}
fecha <- Sys.Date()
fecha
fecha - 7 # una semana antes
class(fecha) # de clase fecha
``` 

Para <mark>**convertir una cadena de texto a fecha**</mark>, basta usar la funci칩n `as.Date()`, pas치ndole como argumento la fecha en formato `"yyyy-mm-dd"` por defecto.

```{r}
as.Date("2021-03-10") # formato por defecto
```

Si **introducimos otro tipo de formato**, debemos especific치rselo en un segundo argumento, para `R` sepa el formato de fecha que le estamos pasando

```{r}
as.Date("10-03-2020", "%d-%m-%Y") # con d칤a-mes-a침o (4 cifras)
as.Date("10-03-20", "%d-%m-%y")  # con d칤a-mes-a침o (2 cifras)
as.Date("03-10-2020", "%m-%d-%Y") # con mes-d칤a-a침o (4 cifras)
as.Date("Octubre 21, 1995 21:24", "%B %d, %Y %H:%M") # fecha escrita
``` 

&nbsp;

**`r colorize("ERROR: sin pasar a fecha no se puede operar", "#dc3545")`**



Si tenemos una fecha como caracter, nunca podremos hacer operaciones (por ejemplo, restarle una unidad temporal, en este caso un d칤a).

```{r error = TRUE}
"2021-03-10" - 1 # error
```

F칤jate la diferencia cuando lo convertimos en fecha

```{r error = TRUE}
fecha <- as.Date("2021-03-10") - 1 # d칤a previo
fecha
``` 


&nbsp;


Dentro del entorno del paquete `{lubridate}` tenemos bastantes funciones 칰tiles para trabajar con fechas como las siguientes


```{r lubridate-package, echo = FALSE, fig.align = 'center',  include = identical(knitr:::pandoc_to(), 'html'), fig.link = 'https://lubridate.tidyverse.org/', out.width = '100%'}
knitr::include_graphics('img/lubridate.png')
```

```{r eval = FALSE}
install.packages("lubridate") # solo la primera vez
```

```{r}
library(lubridate)
ymd_hms("2017-11-28T14:02:00") # convertir a fecha una cadena a침o-mes-d칤a + hora
ydm_hms("2017-22-12 10:00:00") # convertir a fecha una cadena a침o-d칤a-mes + hora
dmy_hms("1 Jan 2017 23:59:59") # convertir a fecha una cadena textual de fecha + hora
mdy("July 4th, 2000") # convertir a fecha una cadena textual de fecha
ymd(20170131)
```

Adem치s el paquete nos proporciona **herramientas para extraer la fecha y hora actuales** con las funciones `today()` y `now()`

```{r}
today()
now()
```

Tambi칠n tenemos disponibles en dicho paquete funciones para extraer facilmente algunas variables temporales como el **d칤a de la semana, el mes o el cuatrimestre**, con las funciones `year()`, `months()`, `day()` o `wday()` (d칤a de la semana).


```{r}
fecha <- now()
year(fecha)
month(fecha)
day(fecha)
wday(fecha, week_start = 1) # D칤a de la semana (empezando por el lunes)
hour(fecha)
minute(fecha)
second(fecha)
week(fecha) # N칰mero de semana (del a침o)
``` 

Al igual que podemos realizar operaciones aritm칠ticas sencillas con las fechas, tambi칠n podemos **realizar comparaciones**, por ejemplo, si el d칤a actual es menor o mayor que otra fecha dada. 

```{r}
fecha_actual <- now()
fecha_actual > ymd(20170131) # Actual vs 2017-01-31
fecha_actual > ymd(21000131) # Actual vs 2100-01-31
``` 

&nbsp;


## Consejos


**`r colorize("CONSEJOS", "#20935E")`**

&nbsp;

**`r colorize("Recuperar un comando y autocompletar", "#20935E")`**

Si haces click con el rat칩n en la consola y pulsas la flecha 춺arriba췉 del teclado, te ir치 apareciendo todo el <mark>**historial de 칩rdenes ejecutadas**</mark>. Es una manera de ahorrar tiempo para ejecutar 칩rdenes similares a las ya ejecutadas. Si empiezas a escribir el nombre de una variable pero no te acuerdas exactamente de su nombre, pulsando **tabulador** te **autocompletar치** solo.

&nbsp;

**`r colorize("Convertir tipos de datos",  "#20935E")`**

A veces la lectura de variables num칠ricas de nuestros archivos puede hacer que un n칰mero, por ejemplo `1`, sea le칤do como la cadena de texto `"1"`, con la que no podemos operar como un n칰mero. Las funciones `as.numeric()`, `as.character()` y `as.logical()` nos permiten convertir una variable en tipo num칠rico, caracter o l칩gico, respectivamente.

```{r error = TRUE}
"1" + 1
as.numeric("1") + 1
as.character(1)
as.logical(c(0, 1))
```

&nbsp;

## 游닇 Ejercicios

(haz click en las flechas para ver soluciones)

<details>
  <summary>游닇<strong>Ejercicio 1</strong>: define una variable que guarde tu edad, otra con tu nombre, otra respondiendo a la pregunta 춺쯦engo hermanos?췉 y otra con la fecha de tu nacimiento. </summary>
  
<!-- toc -->
- Soluci칩n:

```{r}
edad <- 32 # tipo numeric
nombre <- "Javier" # tipo caracter
hermanos <- TRUE # tipo hermanos
fecha_nacimiento <- as.Date("1989-09-10") # tipo fecha
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>游닇<strong>Ejercicio 2</strong>: define otra variable con tus apellidos y junta las variables `nombre` y `apellidos` en una sola variable `nombre_completo`. </summary>
  
<!-- toc -->
- Soluci칩n:

```{r}
# Apellidos
apellidos <- "츼lvarez Li칠bana"

# Pegamos
nombre_completo <- glue("{nombre} {apellidos}")
nombre_completo

# Otra forma
nombre_completo <- paste(nombre, apellidos)
nombre_completo
```

<!-- tocstop -->
</details>

&nbsp;


<details>
  <summary>游닇<strong>Ejercicio 3</strong>: construye una frase que diga 춺Hola, me llamo ... y tengo ... a침os. Nac칤 el ... de ... de ...췉 (con el nombre completo). </summary>
  
<!-- toc -->
- Soluci칩n:

```{r}
dia_nacimiento <- day(fecha_nacimiento)
mes_nacimiento <- month(fecha_nacimiento)
a_nacimiento <- year(fecha_nacimiento)

glue("Hola, me llamo {nombre_completo} y tengo {edad} a침os. Nac칤 el {dia_nacimiento} del {mes_nacimiento} de {a_nacimiento}")
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>游닇<strong>Ejercicio 4</strong>: calcula los d칤as que han pasado desde la fecha de tu nacimiento </summary>
  
<!-- toc -->
- Soluci칩n:

```{r}
days(today() - fecha_nacimiento)
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>游닇<strong>Ejercicio 5</strong>: obt칠n una variable l칩gica que nos diga si se cumplen (todas) las condiciones i) menor de 30 a침os (`edad < 30`); ii) con hermanos (`hermanos == TRUE`); iii) nacido en 1990 o posterior (`fecha_nacimiento >= as.Date("1990-01-01")`). </summary>
  
<!-- toc -->
- Soluci칩n:

```{r}
# Se tienen que cumplir todas
edad < 30 & fecha_nacimiento >= as.Date("1990-01-01") & hermanos
```

```{r}
# otra forma
edad < 30 & fecha_nacimiento >= as.Date("1990-01-01") & hermanos == TRUE
```

<!-- tocstop -->
</details>


&nbsp;

<details>
  <summary>游닇<strong>Ejercicio 6</strong>: modifica el c칩digo del ejercicio anterior para obtener una variable l칩gica que nos diga si se cumplen (al menos) alguna de las condiciones i) menor de 30 a침os; ii) con hermanos; iii) nacido en 1990 o posterior. Al contrario que antes, no necesitamos que se cumplan todas, nos basta con que se cumple al menos una. </summary>
  
<!-- toc -->
- Soluci칩n:

```{r}
# Se tienen que cumplir todas
edad < 30 | fecha_nacimiento >= as.Date("1990-01-01") | hermanos
```

<!-- tocstop -->
</details>


&nbsp;


<details>
  <summary>游닇<strong>Ejercicio 7</strong>: calcula la fecha 11 d칤as m치s tarde a tu fecha de nacimiento. Obt칠n la semana del a침o de dicha fecha y el d칤a de la semana con las funciones `week`, `wday` y `weekdays`. </summary>
  
<!-- toc -->
- Soluci칩n:

```{r}
# Podemos sumar porque es fecha
fecha_post <- fecha_nacimiento + 11
fecha_post

# Semana del a침o
week(fecha_post)

# D칤a de la semana (versi칩n americana, empiezan el domingo)
wday(fecha_post)

# D칤a de la semana (versi칩n espa침ola)
wday(fecha_post, week_start = 1)

# D칤a de la semana en texto
weekdays(fecha_post)
```

<!-- tocstop -->
</details>


&nbsp;



<details>
  <summary>游닇<strong>Ejercicio 8</strong>: define dos n칰meros cualesquiera en variable `a` y `b`. Calcula su suma y determina cual es mayor. </summary>
  
<!-- toc -->
- Soluci칩n:

```{r}
a <- -5
b <- 7

# Suma
c <- a + b
c

# Comparaciones
a == b # 쯔 = b?
a < b # 쯔 < b?
```

<!-- tocstop -->
</details>


&nbsp;


