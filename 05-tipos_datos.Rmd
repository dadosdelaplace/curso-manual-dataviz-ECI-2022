```{r echo = FALSE}
library(knitr)

# Color text
colorize <- function(x, color) {
  
  if (knitr::is_latex_output()) {
    
    sprintf("\\textcolor{%s}{%s}", color, x)
    
  } else if (knitr::is_html_output()) {
    
    sprintf("<span style='color: %s;'>%s</span>", color, x)
    
  } else { x }
}
```

# (PART) Conceptos b√°sicos {-}

# Tipos de datos {#tipos-datos}

:::: {.blackbox data-latex=""}

Scripts usados:

* [**script02.R**](https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script02.R): tipos de datos y funciones usadas con ellos.  Ver en <https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script02.R>

::::

&nbsp;

Tras las lecciones anteriores, los ejercicios planteados y lo que hayas jugueteado por tu cuenta, deber√≠amos saber usar ya `R` como una calculadora. Vamos a ir m√°s all√°: <mark>**¬øexisten datos m√°s all√° de los n√∫meros?**</mark> En este cap√≠tulo vamos a empezar a familiarizarnos con los tipos de datos (individuales) que podemos necesitar. Piensa por ejemplo en los datos guardados de una persona:

* La edad ser√° un <mark>**n√∫mero (sin decimales)**</mark>
* Su peso o estatura ser√° otro <mark>**n√∫mero (ahora con decimales)**</mark>.
* Su nombre ser√° una <mark>**cadena de texto**</mark>.
* Su fecha de nacimiento ser√° precisamente eso, una <mark>**fecha**</mark>.
* A la pregunta ¬´¬øest√° usted soltero/a?¬ª la respuesta ser√° lo que llamamos una <mark>**variable binaria**</mark>: una variable que solo puede valer `TRUE` (si est√° soltero/a) y `FALSE` (en otro caso).

Existen **m√°s tipos** (como n√∫meros complejos) pero con estos nos valdr√° para nuestra introducci√≥n.


## Variables num√©ricas {#numericas}

- [X] Variables num√©ricas (individuales)
- [ ] Variables de caracteres
- [ ] Variables l√≥gicas
- [ ] Variables de tipo fecha

Probablemente el dato **m√°s sencillo y obvio** de entender sean los datos num√©ricos, datos que ya hemos usado en nuestros primeros pasos como calculadora.

```{r}
a <- 1
b <- 2
a + b
```

En el c√≥digo anterior, tanto `a` como `b` como la suma `a + b` son de <mark>**tipo num√©rico**</mark>, algo que podemos comprobar con la funci√≥n `class()` (nos devuelve _numeric_).

```{r}
# Clase de las variables
class(a)
class(b)
class(a + b)
```

Tambi√©n podemos comprobar su naturaleza con `typeof()`, que nos devuelve la naturaleza del dato tal cual es guardada en `R`.

```{r}
# Topolog√≠a interna
typeof(a)
typeof(b)
typeof(a + b)
```

F√≠jate que ambas √≥rdenes combinadas nos dicen que las variables son de tipo num√©rico pero concretamente de tipo _double_: dichas variables son entendidas internamente como n√∫meros con decimales (aunque no los veamos), lo que en **matem√°ticas se llaman n√∫meros reales** (por curiosidad: el t√©rmino _double_ viene de lenguajes de programaci√≥n antiguos como `C`, que significa ¬´doble precisi√≥n¬ª, para indicarle que reserve 8 bytes - 64 bits - de memoria). Durante el curso no distinguiremos entre distintos tipos de n√∫meros, para nosotros ser√°n siempre de clase _numeric_ y de tipo _double_, pero podr√≠amos definir n√∫meros enteros o _integer_ (sin decimales, ahorrando huecos en memoria).

```{r}
# Dato num√©rico (entero)
a <- 1L
class(a)
typeof(a)
```

Con los <mark>**datos num√©ricos**</mark> podemos realizar todas las **operaciones** que se nos ocurrir√≠a hacer en una **calculadora**, como sumar (`+`), restar (`-`), multiplicar (`*`), dividir (`/`), ra√≠z cuadrada (`sqrt()`), valor absoluto (`abs()`), elevar al cuadrado  (`^2`), elevar al cubo (`^3`), etc.


```{r}
# Definimos dos variables num√©ricas
a <- 1
b <- -2

# Suma y resta
a + b
a - b

# Multiplicaci√≥n y divisi√≥n
a * b
a / b

# Ra√≠z cuadrada
sqrt(a)

# Valor absoluto
abs(b)

# Potencias
a^2
b^3
```



## Variables de tipo caracter (texto) {#caracter}

- [X] Variables num√©ricas (individuales)
- [X] Variables de caracteres
- [ ] Variables l√≥gicas
- [ ] Variables de tipo fecha

Pero no solo de n√∫meros viven los datos: imagina que adem√°s de la edad de una persona queremos guardar su nombre.

```{r}
edad <- 32
nombre <- "Javier"

class(edad)
typeof(edad)

class(nombre)
typeof(nombre)
```

F√≠jate que ahora tenemos en `nombre` una variable de tipo _character_, es decir, una cadena de texto (conocido en otros lenguajes como _string_ o _char_): **letras y caracteres entre comillas**. 

### Nuestra primera funci√≥n: paste/paste0


Las <mark>**cadenas de texto**</mark> son un tipo especial de dato, con los que obviamente no podremos hacer operaciones aritm√©ticas, pero si podemos hacer operaciones propias de cadenas de texto como puede ser la funci√≥n `paste()`. Dicha funci√≥n nos permite **pegar dos cadenas de caracteres**, decidiendo que caracter queremos que vaya entre palabra con el argumento `sep =`.

```{r}
nombre <- "Javier"
apellido <- "√Ålvarez"
paste(nombre, apellido, sep = "") # todo junto
paste(nombre, apellido, sep = " ") # separados por un espacio
paste(nombre, apellido, sep = ".") # separados por un punto .
```

Si queremos pegar cadenas de texto sin ning√∫n tipo de caracter, existe una forma m√°s abreviada y limpia de ejecutar la orden, usando la funci√≥n `paste0()` 

```{r}
# Son equivalentes
paste(nombre, apellido, sep = "") # todo junto
paste0(nombre, apellido) # todo junto sin nada separando
```

Cuando hemos ejecutado `paste()` estamos ejecutando lo que se conoce como una <mark>**funci√≥n**</mark>: una palabra reservada que representa un **conjunto de √≥rdenes**, y que se ejecuta a partir de unos <mark>**argumentos de entrada**</mark>. En el caso de la funci√≥n `paste()` puede tener varios argumentos: las cadenas de texto que queremos copiar, y un **argumento opcional** llamado `sep`, que podemos darle un valor con concreto o dejarlo sin especificar. Lo que har√° `R` ser√° tomar su <mark>**valor por defecto**</mark> igual a `sep = " "` (por defecto, la funci√≥n `paste()` pega cadenas de texto con un espacio entre ellas). Prueba a ejecutar `? paste` en consola para ver las opciones en el **panel de ayuda**.

```{r}
# Son equivalentes
paste(nombre, apellido, sep = " ")
paste(nombre, apellido)
```

### Nuestro primer paquete: glue

  
Otra **forma m√°s intuitiva de trabajar con textos y variables num√©ricas** es usar el paquete `{glue}`, que nos permite pegar cadenas de texto a variables num√©ricas de **forma simb√≥lica**.

```{r eval = FALSE}
install.packages("glue") # solo la primera vez
```

```{r}
library(glue)
```

Recuerda que `install.packages()` es solo necesario la primera que ¬´compramos el libro¬ª: nos bajamos una serie de archivos a nuestro ordenador. Una vez que hemos comprado el libro, cada vez que queramos usarlo bastar√° con indicarle que nos traiga ese libro concreto con `library()`.

El paquete `{glue}` nos permite pegar de una forma mucho m√°s legible cadenas de texto

```{r}
# Ejemplo 1
edad <- 32
glue("La edad es de {edad} a√±os")
paste("La edad es de", edad, "a√±os") # equivalente

# Ejemplo 2
edad <- 32
unidades <- "a√±os"
glue("La edad es de {edad} {unidades}")
```

Tambi√©n podemos hacer uso de dicha funci√≥n sin tener los valores num√©ricos previamente guardados en variables.

```{r}
# Otra forma sin definir variables a priori
glue("La edad es de {32} a√±os")
```

&nbsp;


## Variables l√≥gicas (TRUE/FALSE) {#logicas}

- [X] Variables num√©ricas (individuales)
- [X] Variables de caracteres
- [X] Variables l√≥gicas
- [ ] Variables de tipo fecha

Probablemente el tipo de datos m√°s importante en todo lenguaje de programaci√≥n son las <mark>**variables l√≥gicas**</mark>. Un **valor l√≥gico** puede tomar **dos valores** (en realidad pueden tomar un tercer valor, `NA`, las siglas de _not available_ para representar datos ausentes, pero lo veremos m√°s adelante):

* `TRUE` (guardado internamente como un `1`).
* `FALSE` (guardado internamente como un `0`).

Este tipo de variables, tambi√©n conocidas como <mark>**variables binarias (solo dos valores) o booleanas**</mark>, son la base de la programaci√≥n ya que cada bit de nuestro ordenador puede guardar un `1` o un `0`.

```{r}
soltero <- TRUE # ¬øEs soltero? --> S√ç
carnet_conducir <- FALSE # ¬øTiene carnet de conducir? --> NO

class(soltero)
typeof(soltero)

class(carnet_conducir)
typeof(carnet_conducir)
```

Ahora nuestas variables son guardadas como _logical_, y pueden tomar los valores `TRUE/FALSE`, aunque internamente son guardados como `1/0`. Es importante entender que <mark>**no son variables de texto**</mark>:

* `"TRUE"` es un texto (internamente id√©ntico a `rojo` o `azul`)
* `TRUE` es una variable l√≥gica

```{r error = TRUE}
# Texto
texto <- "TRUE"
texto + 1

# L√≥gica
logica <- TRUE
logica + 1
```

Estos valores suelen ser resultado de evaluar <mark>**condiciones l√≥gicas**</mark>. Por ejemplo, imaginemos que queremos comprobar si una persona est√° soltero o no, y si tiene carnet de conducir o no. Basta con que ejecutemos la orden `soltero == TRUE`, que nos devolver√° `TRUE` si est√° soltero, y `FALSE` en caso contrario. De igual manera podremos hacer `carnet_conducir == TRUE`. <mark>**IMPORTANTE**</mark>: cuando queremos **comparar si un elemento es igual a otro**, usaremos el operador de comparaci√≥n `==`, pudiendo usar tambi√©n su opuesto `!=` (¬´distinto de¬ª).


```{r}
soltero == TRUE
soltero != TRUE # igual que soltero == FALSE
carnet_conducir == TRUE
carnet_conducir != TRUE
```

Por el mismo razonamiento podemos <mark>**comparar si una variable num√©rica o de tipo caracter**</mark> es igual o distinto a un valor dado, incluso para las num√©ricas podemos **comparar si son menores o mayores** que un n√∫mero. 

¬øTiene la persona menos de 32 a√±os? ¬øTiene justo 32 a√±os? ¬øTiene 32 a√±os o m√°s?

```{r}
edad < 32
edad == 32
edad >= 32
```

¬øLa persona se llama Carlos?

```{r}
nombre == "Carlos"
```

F√≠jate que para comparaciones tenemos ¬´igual a¬ª `==` frente distinto `!=`, pero tambi√©n comparaciones de orden como `<=`, `>` o `>=`. Las <mark>**condiciones l√≥gicas pueden ser combinadas**</mark>, principalmente de dos maneras:

- **Intersecci√≥n**: todas las condiciones concatenadas se deben cumplir (conjunci√≥n `y`, operador `&`) para devolver un `TRUE`.

- **Uni√≥n**: basta con que una de las condiciones concatenadas se cumpla (conjunci√≥n `o`, operador `|`) para devolver un `TRUE`.

Por ejemplo, podr√≠amos preguntarnos si la persona tiene m√°s de 32 a√±os y est√° soltero (AMBAS deben cumplirse).

```{r}
edad > 32 & soltero == TRUE
# Equivalente (al ser soltero un valor ya de por si l√≥gico)
edad > 32 & soltero
```

Vemos que el resultado es `FALSE` ya que solo se cumple una de las condiciones: devolver√≠a `TRUE` si preguntamos si tiene m√°s de 30 a√±os y est√° soltero, o si solo pedimos una de las dos condiciones (¬øest√° soltero y/o tiene m√°s de 32 a√±os?).

```{r}
edad > 32 | soltero # nos sirve con que alguna se cumpla
edad > 32 & soltero # deben cumplirse ambas
edad > 30 & soltero # deben cumplirse ambas
```

## Variables de tipo fecha {#fechas}

- [X] Variables num√©ricas (individuales)
- [X] Variables de caracteres
- [X] Variables l√≥gicas
- [X] Variables de tipo fecha

Por √∫ltimo, vamos a ver un tipo de datos muy especial: los <mark>**datos de tipo fecha**</mark>. Una fecha podr√≠a ser a priori una simple cadena de texto `"2021-04-21"` pero podemos usar la funci√≥n `as.Date()` para que `R` entienda que esa cadena de texto representa un instante temporal. F√≠jate la diferencia entre una fecha en texto y una fecha con `as.Date()`.

```{r error = TRUE}
# Cadena de texto
fecha_char <- "2021-04-21"
fecha_char + 1

# Fecha, mostrada como un texto pero guardada internamente como un n√∫mero
fecha_date <- as.Date(fecha_char, format = "%Y-%m-%d")
fecha_date + 1
```

En el momento en que convertimos la cadena de texto a fecha, aunque se visualice como un texto, internamente es un n√∫mero, por lo que podemos restar fechas (d√≠as entre ambas), **podemos sumar n√∫meros a fechas (fecha d√≠as despu√©s)**, etc. Como ya hemos dicho, **las fechas y momentos temporales no ser√°n meras cadenas de caracter sino que tienen clases especiales asociadas**. Las fechas ser√°n guardadas internamente como el **n√∫mero de d√≠as transcurridos desde el 1 de enero de 1970**, y las horas como **n√∫mero de segundos desde el 1 de enero de 1970** (para la clase `POSIXct`) o una lista de segundos, minutos y horas (para la clase `POSIXlt`).

¬øC√≥mo <mark>**obtener autom√°ticamente la fecha de hoy**</mark>? La funci√≥n `Sys.Date()` nos devuelve directamente la fecha y hora en el momento de la ejecuci√≥n de la orden.

```{r}
fecha <- Sys.Date()
fecha
fecha - 7 # una semana antes
class(fecha) # de clase fecha
``` 

Para <mark>**convertir una cadena de texto a fecha**</mark>, basta usar la funci√≥n `as.Date()`, pas√°ndole como argumento la fecha en formato `"yyyy-mm-dd"` por defecto.

```{r}
as.Date("2021-03-10") # formato por defecto
```

Si **introducimos otro tipo de formato**, debemos especific√°rselo en un segundo argumento, para `R` sepa el formato de fecha que le estamos pasando

```{r}
as.Date("10-03-2020", "%d-%m-%Y") # con d√≠a-mes-a√±o (4 cifras)
as.Date("10-03-20", "%d-%m-%y")  # con d√≠a-mes-a√±o (2 cifras)
as.Date("03-10-2020", "%m-%d-%Y") # con mes-d√≠a-a√±o (4 cifras)
as.Date("Octubre 21, 1995 21:24", "%B %d, %Y %H:%M") # fecha escrita
``` 

&nbsp;

**`r colorize("ERROR: sin pasar a fecha no se puede operar", "#dc3545")`**

Si tenemos una fecha como caracter, nunca podremos hacer operaciones (por ejemplo, restarle una unidad temporal, en este caso un d√≠a).

```{r error = TRUE}
"2021-03-10" - 1 # error
```

F√≠jate la diferencia cuando lo convertimos en fecha

```{r error = TRUE}
fecha <- as.Date("2021-03-10") - 1 # d√≠a previo
fecha
``` 


&nbsp;


Dentro del entorno del paquete `{lubridate}` tenemos bastantes funciones √∫tiles para trabajar con fechas como las siguientes


```{r lubridate-package, echo = FALSE, fig.align = 'center',  include = identical(knitr:::pandoc_to(), 'html'), fig.link = 'https://lubridate.tidyverse.org/', out.width = '100%'}
knitr::include_graphics('img/lubridate.png')
```

```{r eval = FALSE}
install.packages("lubridate") # solo la primera vez
```

```{r}
library(lubridate)
ymd_hms("2017-11-28T14:02:00") # convertir a fecha una cadena a√±o-mes-d√≠a + hora
ydm_hms("2017-22-12 10:00:00") # convertir a fecha una cadena a√±o-d√≠a-mes + hora
dmy_hms("1 Jan 2017 23:59:59") # convertir a fecha una cadena textual de fecha + hora
mdy("July 4th, 2000") # convertir a fecha una cadena textual de fecha
ymd(20170131)
```

Adem√°s el paquete nos proporciona **herramientas para extraer la fecha y hora actuales** con las funciones `today()` y `now()`

```{r}
today()
now()
```

Tambi√©n tenemos disponibles en dicho paquete funciones para extraer facilmente algunas variables temporales como el **d√≠a de la semana, el mes o el cuatrimestre**, con las funciones `year()`, `months()`, `day()` o `wday()` (d√≠a de la semana).


```{r}
fecha <- now()
year(fecha)
month(fecha)
day(fecha)
wday(fecha, week_start = 1) # D√≠a de la semana (empezando por el lunes)
hour(fecha)
minute(fecha)
second(fecha)
week(fecha) # N√∫mero de semana (del a√±o)
``` 

Al igual que podemos realizar operaciones aritm√©ticas sencillas con las fechas, tambi√©n podemos **realizar comparaciones**, por ejemplo, si el d√≠a actual es menor o mayor que otra fecha dada. 

```{r}
fecha_actual <- now()
fecha_actual > ymd(20170131) # Actual vs 2017-01-31
fecha_actual > ymd(21000131) # Actual vs 2100-01-31
``` 

&nbsp;


## Consejos


**`r colorize("CONSEJOS", "#20935E")`**

&nbsp;

**`r colorize("Recuperar un comando y autocompletar", "#20935E")`**

Si haces click con el rat√≥n en la consola y pulsas la flecha ¬´arriba¬ª del teclado, te ir√° apareciendo todo el <mark>**historial de √≥rdenes ejecutadas**</mark>. Es una manera de ahorrar tiempo para ejecutar √≥rdenes similares a las ya ejecutadas. Si empiezas a escribir el nombre de una variable pero no te acuerdas exactamente de su nombre, pulsando **tabulador** te **autocompletar√°** solo.

&nbsp;

**`r colorize("Convertir tipos de datos",  "#20935E")`**

A veces la lectura de variables num√©ricas de nuestros archivos puede hacer que un n√∫mero, por ejemplo `1`, sea le√≠do como la cadena de texto `"1"`, con la que no podemos operar como un n√∫mero. Las funciones `as.numeric()`, `as.character()` y `as.logical()` nos permiten convertir una variable en tipo num√©rico, caracter o l√≥gico, respectivamente.

```{r error = TRUE}
"1" + 1
as.numeric("1") + 1
as.character(1)
as.logical(c(0, 1))
```

&nbsp;

## üìù Ejercicios

(haz click en las flechas para ver soluciones)

<details>
  <summary>üìù<strong>Ejercicio 1</strong>: define un vector que contenga los n√∫meros 1, 10, -1 y 2, y gu√°rdalo en una variable llamada `vector_num`. </summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
# Vector de n√∫meros
vector_num <- c(1, 10, -1, 2)
vector_num
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 2</strong>: crea un vector con las palabras "Hola", "me", "llamo" (y tu nombre y apellidos), y pega luego sus elementos de forma que la frase est√© correctamente escrita en castellano. Tras hacerlo, a√±ade "y tengo 30 a√±os". </summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
# Definiendo el vector
vector_char <- c("Hola", "me", "llamo", "Javier",
                 "√Ålvarez", "Li√©bana")

# Pegamos
paste(vector_char, collapse = " ")

# A√±adimos frase
paste0(paste(vector_char, collapse = " "), " y tengo 30 a√±os.")
```

<!-- tocstop -->
</details>

&nbsp;



