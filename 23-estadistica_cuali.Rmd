```{r echo = FALSE}
library(knitr)

# Color text
colorize <- function(x, color) {
  
  if (knitr::is_latex_output()) {
    
    sprintf("\\textcolor{%s}{%s}", color, x)
    
  } else if (knitr::is_html_output()) {
    
    sprintf("<span style='color: %s;'>%s</span>", color, x)
    
  } else { x }
}
```

# (PART) Incursi칩n a la estad칤stica descriptiva {-}

# Extrayendo informaci칩n: estad칤stica descriptiva con cualitativas {#descriptiva_cualitativas}

:::: {.blackbox data-latex=""}

Scripts usados:

* [**script23.R**](https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script23.R): intro a la descriptiva con cualitativas.  Ver en <https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script23.R>
::::

Como ya hemos comentado, algunas de las grandes **fortalezas** de `R` frente a `Python` est치n relacionadas con la disponibilidad de herramientas para <mark>**generar informes**</mark> y herramientas de <mark>**visualizaci칩n y procesamiento de datos**</mark>. Pero si `R` es tan conocido en ciencias es por ser un lenguaje de programaci칩n sencillo para aplicar estad칤stica y Machine Learning, con una inmensa cantidad de paquetes relacionados con ello. En este bloque vamos a introducirnos a la <mark>**estad칤stica descriptiva**</mark> en varios niveles:

- <mark>**An치lisis univariante de variables categ칩ricas**</mark>: una sola variable que representa una categor칤a o cualidad.
- <mark>**An치lisis univariante de variables continuas**</mark>: una sola variable que representa una variable cuantificable num칠ricamente.
- <mark>**An치lisis multivariante de distintos tipos de variables**</mark>: varias variables a la vez


## 쯈u칠 es la estad칤stica descriptiva?

Una buena definici칩n de estad칤stica puede ser la encontrada en wikipedia:

> La estad칤stica (la forma femenina del t칠rmino alem치n Statistik, derivado a su vez del italiano statista, "hombre de Estado"), es la rama de la matem치tica que estudia la variabilidad, colecci칩n, organizaci칩n, an치lisis, interpretaci칩n, y presentaci칩n de los datos, as칤 como el proceso aleatorio que los genera siguiendo las leyes de la probabilidad.

La **estad칤stica descriptiva** es la herramienta fundamental para obtener esa informaci칩n, para obtener valor de los datos generados a partir de los sucesos de estudio mediante la <mark> 
**descripci칩n, visualizaci칩n y agregaci칩n**</mark> de los mismos.

### Poblaci칩n y muestra

El uso primigenio de la estad칤stica, y de donde deriva etimol칩gicamente la palabra, es el <mark>**estudio y organizaci칩n del Estado**</mark>, por lo que muchos t칠rminos hacen referencia a dicho origen. Vamos a <mark>**introducir algunos t칠rminos**</mark> usando como ejemplo el conjunto que ya conocemos de `starwars`, en el que tenemos datos de **87 personajes**.

* <mark>**Poblaci칩n**</mark>: el conjunto o <mark>**colecci칩n de individuos**</mark> a estudiar (por ejemplo, los cientos de miles de habitantes de los mundos de Star Wars). En general llamaremos poblaci칩n al <mark>**conjunto de posibles elementos o eventos**</mark> de los que podr칤amos tener observaciones. El problema es que esa poblaci칩n normalmente es <mark>**inaccesible**</mark> su totalidad (en el caso de obtener estad칤sticas de la estatura de toda la poblaci칩n espa침ola, ser칤a inviable medir a los 47 millones de habitantes).

* <mark>**Individuo**</mark>: cada uno de los **elementos** sobre los que vamos a **medir una caracter칤stica** (normalmente las filas de una tabla)

* <mark>**Muestra**</mark>: una <mark>**selecci칩n 춺representativa췉**</mark> de la poblaci칩n total (te칩rica). En nuestro caso, de los miles de habitantes de los mundos de Star Wars hemos extra칤do una muestra de 87 personas. La rama de la estad칤stica que se encarga del estudio de c칩mo obtener esas muestras, en funci칩n del objetivo que se tenga, se conoce como <mark>**muestreo**</mark>. 

```{r}
library(tidyverse)

# Nuestra muestra
starwars
```

* <mark>**Tama침o muestral**</mark>: comunmente denotado como $n$, es el n칰mero de individuos seleccionados de nuestra poblaci칩n (normalmente el n칰mero de filas de nuestros conjuntos de datos).


```{r}
# Tama침o muestral
nrow(starwars)
```

### Incursi칩n en lo aleatorio

Un <mark>**experimento aleatorio**</mark> es aquel cuyo resultado inmediato, para cada individuo, no es posible saber con certeza, aunque eso no impida definir y conocer su patr칩n a <mark>**nivel poblacional (te칩rico)**</mark>. No sabemos que saldr치 en el dado en cada tirada pero s칤 la probabilidad de cada d칤gito, pudiendo incluso <mark>**inferir**</mark> resultados de nuestra poblaci칩n en funci칩n de nuestras muestras (tiradas): si de 1 mill칩n de veces que tiramos el dado, en el 90% de ellas sale un 1, usando el conocimiento probabil칤stico de que la probabilidad de cada n칰mero deber칤a ser de $1/6$, podr칤amos inferir que nuestro dado podr칤a estar trucado.

La forma m치s sencilla de <mark>**generar una muestra aleatoria**</mark> en `R` es con la funci칩n `sample()`, indic치ndole los siguientes argumentos:

* `x`: los valores posibles (lo que se conoce como dominio). Por ejemplo, en el caso de una moneda, ser치n `"cara"` y `"cruz"`.

* `size`: el n칰mero de veces que realizamos la extracci칩n aleatoria (el n칰mero de tiradas).

* `replace`: en caso de estar `TRUE`, permitir치 que puedan salir valores repetidos (por ejemplo, `cara, cara`). En caso de ser `FALSE`, es como una urna de bolas de forma que tras cada extracci칩n la bola nunca vuelve a la urna: solo se podr치 realizar el experimento un m치ximo de veces igual al n칰mero de elementos en `x`

```{r}
valores_moneda <- c("cara", "cruz")
sample(x = valores_moneda, size = 30, replace = TRUE)
```

Si lo ejecutamos de nuevo, al ser aleatorio, saldr치n otras **30 tiradas distintas**.

```{r}
sample(x = valores_moneda, size = 30, replace = TRUE)
```

En el caso de la moneda es un experimento en el que los posibles sucesos son <mark>**equiprobables**</mark>: ambos tienen la mismas opciones de salir. Si tuvi칠semos el equivalente a una moneda trucada, donde por ejemplo `"cara"` tuviese un 0.7 de probabilidad y `"cruz"` un 0.3 (la suma debe ser siempre igual 1), obtendr칤amos tiradas muy diferentes. Para indicarle que las probabilidades asociadas al experimento no son iguales, usaremos el argumento `probs`, pas치ndole un vector con dichas probabilidades

```{r}
tirada_equi <- sample(x = valores_moneda, size = 500, replace = TRUE)
tirada_trucada <- sample(x = valores_moneda, size = 500, prob = c(0.7, 0.3), replace = TRUE)

# N칰mero de caras (de 500 tiradas)
sum(tirada_equi == "cara")
sum(tirada_trucada == "cara")
```

### Caracter칤sticas y modalidades

En estad칤stica llamamos <mark>**caracteres**</mark> a cada una de las variables o **columnas de una tabla**, cada una de las **caracter칤sticas o cualidades que se miden/estudian** para cada uno de los individuos seleccionados en la muestra. En el caso de `starwars`, podemos extraer su nomnbre con `names()`

```{r}
# N칰mero de caracter칤sticas medidas
ncol(starwars)

# Caracter칤sticas
names(starwars)
```

Y para cada una de ellas llamaremos <mark>**modalidades**</mark> a los **diferentes valores que puede adoptar** una caracter칤stica o variable. En el caso por ejemplo del fichero de `starwars` tenemos distintas opciones:

* `sex`: tiene 4 modalidades `female, hermaphroditic, male, none` (podemos extraerlas con `unique()`, que nos dar치 los valores 칰nicos de una variable).

```{r}
unique(starwars$sex)
```

* `mass`: su modalidad son todos los n칰meros reales positivos hasta un peso m치ximo (es lo que se conoce como una variable continua).


En estad칤stica, como en probabilidad, podemos distinguir las variables en funci칩n de las modalidades permitidas en dos grandes categor칤as:

* <mark>**Variables categ칩ricas (nominales o cualitativas)**</mark>. Son variables que representan categor칤as o cualidades. Ejemplos: color, forma, estado civil, religi칩n, etc. Estas variables las podemos <mark>**subdividir en funci칩n de si admiten o no un orden**</mark>:
  - <mark>**Cualitativas ordinales**</mark>: aunque representen cualidades, tienen una jerarqu칤a de orden. Ejemplos: suspenso-aprobado-notable, sano - herido leve - grave, etc.
  - <mark>**Cualitativas nominales**</mark>: no admiten (salvo problemas nuestros) una jerarqu칤a de orden. Ejemplos: ateo-cat칩lico-musulm치n, soltero-casado, homber-mujer, etc.
  
* <mark>**Variables cuantitativas**</mark>:  representan una **cantidad num칠rica** medible, una caracter칤stica cuantificable matem치ticamente. A su vez se pueden subdividir en dos grupos.
  - <mark>**Cuantitativas discretas**</mark>: se pueden **contar** y **enumerar (aunque sean infinitos)**, detr치s de un valor puedo saber cu치l viene despu칠s (personas, granos de arena, etc).
  - <mark>**Cuantitativas continuas**</mark>: no solo toman infinitos valores sino que entre dos valores cualesquiera, tambi칠n hay infinitos t칠rminos, no se puede determinar el siguiente valor a uno dado (estaturas, pesos, temperatura, etc).


## An치lisis univariante: categ칩ricas

Como hemos comentado, vamos a empezar introduciendo algunas t칠cnicas de an치lisis estad칤stica para <mark>**variables cualitativas o categ칩ricas**</mark> de manera <mark>**univariante**</mark>, variable a variable, analizando cada una de las columnas de un dataset de manera independiente del resto.

### Factores

En el caso de las **variables cualitativa**, llamaremos  <mark>**niveles o modalidades**</mark>  a los <mark>**diferentes valores**</mark> que pueden tomar estos datos. Por ejemplo, en el caso de la variable `sex` del conjunto `starwars`, tenemos 4 niveles permitidos: `female`, `hermaphroditic`, `male` y `none` (am칠n de datos ausentes). Como ya hemos comentado en algunos apartados anteriores, este tipo de variables se conocen en `R` como <mark>**factores en R**</mark>. Y el paquete fundamental para tratarlos es `{forcats}` (del entorno `{tidyverse}`). Este paquete nos permite fijar los <mark>**niveles**</mark> (guardados internamente como `levels`) que toma una determinada variable categ칩rica para que no puedan generarse equivocaciones, errores en la recolecci칩n y generaci칩n de datos. Adem치s hace que su an치lisis sea menos costoso computacionalmente a la hora de hacer b칰squedas y comparativas.

Veamos un ejempo sencillo definiendo una variable `estado` que tome los valores `"sano"`, `"leve"` y `"grave"` de la siguiente manera.

```{r}
estado <-
  c("grave", "leve", "sano", "sano", "sano", "grave",
    "grave", "leve", "grave", "sano", "sano")
estado
```

La variable `estado` actualmente es de tipo texto, de tipo `chr`, algo que podemos comprobar con `class(estado)`.

```{r}
class(estado)
```

Desde un punto de vista estad칤stico y computacional, para `R` esta variable ahora mismo ser칤a equivalente una variable de nombres. Pero estad칤sticamente no es lo mismo una variable con nombres (que identifican muchas veces el registro) que una variable categ칩rica como estado que <mark>**solo puede tomar esos 3 niveles**</mark>.

<mark>**쮺칩mo convertir una variable a cualitativa o factor?**</mark> Haciendo uso de la funci칩n `as_factor` del paquete `{forcats}`.

```{r}
library(tidyverse)
estado_fct <- as_factor(estado)
estado_fct
class(estado_fct)
```

No solo ha cambiado la clase de la variable sino que ahora, debajo del valor guardado, nos aparece la frase `Levels: grave leve sano`: son las **modalidades o niveles** de nuestra cualitativa. Imagina que ese d칤a en el hospital no tuvi칠semos a <mark>**nadie en estado grave**</makr>: aunque ese d칤a nuestra variable no tome dicho valor, el estado `grave` es un nivel permitido que podr칤amos tener, as칤 que aunque lo eliminemos, por ser un factor, el nivel permanece (no lo tenemos ahora pero es un nivel permitido).-

```{r}
estado_fct[estado_fct %in% c("sano", "leve")]
```

Si queremos indicarle que <mark>**elimine un nivel no usado en ese momento**</mark> podemos hacerlo con `fct_drop()`

```{r}
fct_drop(estado_fct[estado_fct %in% c("sano", "leve")])
```

Al igual que podemos eliminar niveles podemos <mark>**ampliar los niveles existentes**</mark> (aunque no existan datos de ese nivel en ese momento) con `fct_expand()`

```{r}
fct_expand(estado_fct, c("UCI", "fallecido"))
```

Aunque luego veremos como usar el `count()`, para variables de tipo factor podemos <mark>**contar los elementos de cada nivel** de una manera sencilla con `fct_count()`

```{r}
fct_count(estado_fct)
```

Si te fijas el orden de los niveles es por orden de aparici칩n en la variable, pero podemos <mark>**ordenarlos por aparici칩n**</mark> con `fct_infreq()`

```{r}
fct_infreq(estado_fct)
```

A veces queremos <mark>**agrupar niveles**</mark>, por ejemplo, no permitiendo niveles que no sucedan un m칤nimo de veces. Con `fct_lump_min(estado_fct, min = 4)` le indicaremos que para que exista el nivel debe de suceder al menos 4 veces (las observaciones que no lo cumplan ir치n a un nivel gen칠rico llamado `Other`, aunque se puede cambiar con el argumento `other_level`). Podemos hacer algo equivalente pero en funci칩n de su frecuencia relativa con `fct_lump_prop()`.

```{r}
fct_lump_min(estado_fct, min = 3)
fct_lump_min(estado_fct, min = 5)
fct_lump_min(estado_fct, min = 5, other_level = "otros")
```

Como ya hemos usado (y veremos en detalle un poco m치s adelante), con `count()` tambi칠n podemos los valores de una variable asociados a cada modalidad. Por ejemplo, vamos a calcular la cantidad de personajes de cada especie (filtrando los ausentes).

```{r}
starwars %>%
  filter(!is.na(species)) %>%
  count(species)
```

Ahora que sabemos hacerlo podemos dibujar un <mark>**diagrama de barras**</mark> para visualizar el n칰mero de personajes de cada especie (con `fill = n` y `scale_fill_continuous_tableau()` asignaremos un gradiente de color en funci칩n de la frecuencia).

```{r}
ggplot(starwars %>%
         filter(!is.na(species)) %>%
         count(species),
       aes(y = species, x = n, fill = n)) +
  geom_col() +
  scale_fill_continuous_tableau() +
  labs(fill = "Frecuencia absoluta",
       x = "N칰mero de personajes", y = "Especies")
```

Al tener muchos niveles de `species` con muy pocos elementos, tenemos un gr치fico poco claro, as칤 que vamos a indicarle que nos convierta `species` a factor, y que nos <mark>**agrupe aquellas niveles**</mark> que tengan menos de 2 personajes.


```{r}
ggplot(starwars %>%
         filter(!is.na(species)) %>%
         mutate(species =
                  fct_lump_min(species, min = 3,
                               other_level = "Otras especies")) %>%
         count(species),
       aes(y = species, x = n, fill = n)) +
  geom_col() +
  scale_fill_continuous_tableau() +
  labs(fill = "Frecuencia absoluta",
       x = "N칰mero de personajes", y = "Especies")
```

Por 칰ltimo vamos a aplicar algunos ajustes del tema que ya hemos visto en apartados anteriores para terminar nuestro gr치fico.

```{r}
library(showtext)
font_add_google(family = "Roboto", name = "Roboto")
showtext_auto()

ggplot(starwars %>%
         filter(!is.na(species)) %>%
         mutate(species =
                  fct_lump_min(species, min = 3,
                               other_level = "Otras especies")) %>%
         count(species),
       aes(y = species, x = n, fill = n)) +
  geom_col() +
  scale_fill_continuous_tableau() +
  labs(fill = "Frecuencia absoluta",
       x = "N칰mero de personajes", y = "Especies") +
  theme(panel.background = element_rect(fill = "white"),
        plot.background = element_rect(fill = "white", 
                                       color = "white"),
        panel.grid.major.y =
          element_line(size = 0.05, color = "black"),
        panel.grid.major.x =
          element_line(size = 0.1, color = "black"),
        text = element_text(size = 13),
        axis.title =
          element_text(family = "Roboto", size = 23),
        axis.text.x = element_text(family = "Roboto",
                                   size = 15),
        axis.text.y = element_text(family = "Roboto",
                                   size = 15))
```

  
### Tablas de frecuencias

Una de las **primeras cosas** que uno aprende en la asignatura de estad칤stica **descriptiva** es <mark>**saber resumir nuestros datos**</mark> cuando tenemos muchos, y adem치s **muchos valores repetidos**. Vamos a construir la <mark>**tabla de frecuencias**</mark> de la variable `n_films` de nuestro ya conocido conjunto `starwars` (una variable que vamos a crear contando en cu치ntas pel칤culas aparece cada personaje con `map_int()` para aplicar la funci칩n `length()` a cada lista de cada personaje guardada en `films`)

```{r}
library(purrr)
library(tidyverse)
starwars_nueva <- starwars %>%
  mutate(n_films = map_int(films, length))
```


Y lo primero es <mark>**contar**</mark>: 쯖u치ntos registros hay de cada una de las clases? Para ello usaremos la funci칩n `count()`

```{r}
starwars_nueva %>% count()
```

Como ves si aplicamos la **funci칩n directamente** simplemente nos **cuenta el n칰mero de filas** de la tabla, as칤 que vamos a **usar la misma funci칩n pero indic치ndole la variable creada**.

```{r}
tabla_freq <- starwars_nueva %>% count(n_films)
tabla_freq
```

Esa columna `n` es lo que conocemos como <mark>**frecuencias absolutas**</mark>, el **n칰mero de veces** que la variable toma dicha valor. 


* <mark>**Frecuencias absolutas**</mark>: contar cu치ntos elementos aparecen de un determinado nivel. Suele ser denotada como $n_i$, para cada nivel $i$.
* <mark>**Frecuencias relativas**</mark>: contar que proporci칩n del total representa dicha cantidad. Suele ser denotada como $f_i$, para cada nivel $i$.

Esa frecuencia absoluta tambi칠n podemos calcularla haciendo uso de `table()`, aplicada a la variable extra칤da de la tabla.

```{r}
table(starwars_nueva$n_films)
class(table(starwars_nueva$n_films))
```

El formato de la salida de `table()` es lo que se conoce como una  <mark>**tabla de contingencia**</mark>. Aplicada a una sola variable es una **tabla unidimensional** con una fila compuesto por los niveles y una segunda con la frecuencia absoluta de cada uno de ellos. Si lo aplicamos a dos variables el resultado ser치 una <mark>**tabla de contigencia bidimensional**</mark>: la primera variable en las filas, la segunda en las columnas, y realizar치 el conteo bidimensional $n_ij$ para cada par de niveles $(i, j)$

```{r}
table(starwars_nueva %>% select(sex, n_films))
```

Una vez que tenemos las frecuencias absolutas, las relativas se pueden calcular de forma sencilla con `prop.table()`, que nos calcula la proporci칩n que representa dicho valor.

```{r}
# Construimos de cero
tabla_freq <- starwars_nueva %>%
  # n: frecuencia absoluta
  count(n_films) %>%
  # f_i: frecuencia relativa
  mutate(f_i = prop.table(n))
tabla_freq
```


Es importanten observar que `prop.table()` debe aplicarse sobre una <mark>**tabla de contingencia**</mark>. No nos da error al aplicarlo sobre un vector n칰merico, pero lo que nos dar치 no son la **frecuencias relativas** del vector num칠rico si no de un vector que tuviera esos n칰meros como **frecuencias absolutas**.

```{r}
prop.table(starwars_nueva$n_films)
```

Tambi칠n es posible <mark>**calcular frecuencias absolutas bidimensionales**</mark> por varias variables a la vez dentro de `{tidvyerse}` con el propio `count()`, pas치ndole dos variables diferentes.

```{r}
starwars_nueva %>% count(sex, gender)
```

Podemos tambi칠n a침adir una columna $N_i$ de <mark>**frecuencia absoluta acumulada**</mark>, una columna que nos diga el **n칰mero de personajes que han hecho un n칰mero de pel칤culas igual o menor** que el indicado (usando la funci칩n `cumsum()` que nos realiza esa suma acumulada).


```{r}
# Construimos de cero
tabla_freq <-
  starwars_nueva %>%
  # n: frecuencia absoluta
  count(n_films) %>%
  mutate(f_i = prop.table(n),
         N_i = cumsum(n)) # cumsum calcula la suma acumulada
tabla_freq
```

Y al igual que suced칤a con  $n_i$, la frecuencia absoluta acumulada  $N_i$  podremos tambi칠n convertirla a <mark>**frecuencia relativa acumulada**</mark>.

```{r}
# Construimos de cero
tabla_freq <- starwars_nueva %>%
  count(n_films) %>%
  mutate(N_i = cumsum(n)) %>% # cumsum calcula la suma acumulada
  mutate(f_i = prop.table(n), # prop.table nos devuelve proporciones
         F_i = cumsum(f_i))
tabla_freq

# otra forma
tabla_freq <- starwars_nueva %>%
  count(n_films) %>%
  mutate(N_i = cumsum(n)) %>%
  mutate(f_i = prop.table(n),
         F_i = prop.table(N_i))
tabla_freq
```

Esas **frecuencias relativas** quiz치s querramos tenerlas expresadas en <mark>**porcentajes**</mark> en lugar de en proporciones, lo que podemos f치cilmente multiplicando esas proporciones por 100.

```{r}
# Pasamos frecuencias relativas a porcentajes
tabla_freq %>% mutate(f_i = f_i * 100,
                      F_i = F_i * 100)
```

Por 칰ltimo, con la tabla `tabla_freq` expresando las frecuencias relativas en proporciones, vamos a cambiar el nombre de las columnas para que tengan los **t칤picos nombres de una tabla de frecuencias**.

```{r}
# Renombramos
tabla_freq <- tabla_freq %>%
  rename(n_i = n, x_i = n_films)
tabla_freq
```

Con el paquete `{DT}` se pueden visualizar tablas en documentos `.Rmd`

```{r, echo = FALSE, message = FALSE}
library(DT)
datatable(options =
            list(pageLength = 10, scrollX = TRUE,
                 fixedColumns = list(leftColumns = 1),
                 headerCallback = DT::JS(
                   "function(thead) {",
                   "  $(thead).css('font-size', '0.95em');",
                   "}"
                   ),
                 language =
                   list(url = '//cdn.datatables.net/plug-ins/1.10.11/i18n/Spanish.json')),
          tabla_freq, rownames = FALSE,
          caption = "Tabla de frecuencias del n칰mero de pel칤culas en las que aparecen los personajes de la saga.") %>%
   formatRound(c("f_i", "F_i"), digits = 3, mark = ".",
                 dec.mark = getOption("OutDec"))
```


&nbsp;

<mark>**쮺u치l es el color de pelo que m치s aparece en `starwars`?**</mark>

Vamos a construir su tabla de frecuencias, primero conviertiendo `hair_color` a factor y viendo los niveles de dicha variable, y qued치ndonos solo con la variables `name` y `hair_color`. Adem치s <mark>**los niveles ausentes los vamos a convertir**</mark> a `"none"`, nivel que ya existe, con `fct_explicit_na()`

```{r}
starwars_hair <-
  starwars %>%
  mutate(hair_color = fct_explicit_na(hair_color, na_level = "none")) %>%
  select(c(name, hair_color))
starwars_hair
```

Tras el preprocesamiento <mark>**construimos nuestra tabla de frecuencias**</mark>.

```{r}
tabla_freq <- starwars_hair %>%
  count(hair_color) %>%
  mutate(N_i = cumsum(n)) %>% # cumsum calcula la suma acumulada
  mutate(f_i = prop.table(n), # prop.table nos devuelve proporciones
         F_i = cumsum(f_i))
tabla_freq

# En porcentaje
tabla_freq <- 
  tabla_freq %>% mutate(f_i = 100 * f_i,
                        F_i = 100 * F_i)
tabla_freq 
```

En este caso las **frecuencias acumuladas** no nos aportan ning칰n significado ya que la variable que estamos resumiendo es cualitativa nominal, no hay un orden entre los colores (c칩mo si lo hab칤a entre el n칰mero de pel칤culas, que era una variable cuantitativa discreta).


### An치lisis gr치fico

El principal diagrama para variables cualitativas (o cuantitativas discretas) es el <mark>**diagrama de barras**</mark> que ya hemos aprendido a generar y personalizar.

```{r}
library(showtext)
font_add_google(family = "Roboto", name = "Roboto")
showtext_auto()

ggplot(starwars %>%
         filter(!is.na(species)) %>%
         mutate(species =
                  fct_lump_min(species, min = 3,
                               other_level = "Otras especies")) %>%
         count(species),
       aes(y = species, x = n, fill = n)) +
  geom_col() +
  scale_fill_continuous_tableau() +
  labs(fill = "Frecuencia absoluta",
       x = "N칰mero de personajes", y = "Especies") +
  theme(panel.background = element_rect(fill = "white"),
        plot.background = element_rect(fill = "white", 
                                       color = "white"),
        panel.grid.major.y =
          element_line(size = 0.05, color = "black"),
        panel.grid.major.x =
          element_line(size = 0.1, color = "black"),
        text = element_text(size = 13),
        axis.title =
          element_text(family = "Roboto", size = 23),
        axis.text.x = element_text(family = "Roboto",
                                   size = 15),
        axis.text.y = element_text(family = "Roboto",
                                   size = 15))
```


Otra opci칩n con variables cualitativas, en especial para <mark>**visualizar palabras en textos y documentos**</mark> son precisamente las _word cloud_ o nubes de palabras. Con el paquete `{wordcloud2}` podrmeos visualizar las nubes de t칠rminos, por ejemplo de las especies de `starwars` (una vez filtrados los datos dusentes y reagrupado aquellas especies con solo un personaje). Con los par치metros `size` y `color` le indicaremos el tama침o base de las palabras y el patr칩n de colores elegir. Las palabras las visualizar치 en un tama침o relativo al n칰mero de veces que aparece.

```{r}
# install.packages("wordcloud2)
library(wordcloud2)
wordcloud2(starwars %>% drop_na(species) %>%
             mutate(species =
                      fct_lump_min(species, min = 2,
                                   other_level = "otras")) %>% 
             count(species),
           size = 0.8, color= 'random-dark')
```

Otra opci칩n habitual son los <mark>**mosaicos o treemaps**</mark>, representando en una cuadr칤cula cada una de las categor칤as, cuya 치rea sea proprocional a las veces que aparece. Lo haremos con `{treemapify}`, dentro de la l칩gica `{ggplot2}`: los par치metros dentro de `aes()` ser치n 
`area` (asociado a la frecuencia absoluta), `fill` (color del relleno) y `label` (nombre). Usaremos una de las paletas de colores de cuadros vistas, en este caso `MetBrewer::met.brewer("Renoir")`.

```{r}
# install.packages("treemapify")
library(treemapify)
ggplot(starwars %>% drop_na(species) %>%
         mutate(species =
                      fct_lump_min(species, min = 2,
                                   other_level = "otras")) %>%
         count(species),
       aes(area = n, fill = species, label = species)) +
  geom_treemap() +
  scale_fill_manual(values = MetBrewer::met.brewer("Renoir")) +
  labs(fill = "Especies")
```

Con `geom_treemap_text()` podemos adem치s escribir el nombre de los niveles, pudiendo eliminar la leyenda.

```{r}
ggplot(starwars %>% drop_na(species) %>%
         mutate(species =
                      fct_lump_min(species, min = 2,
                                   other_level = "otras")) %>%
         count(species),
       aes(area = n, fill = species, label = species)) +
  geom_treemap() +
  geom_treemap_text(colour = "white", place = "centre",
                    size = 17) +
  scale_fill_manual(values = MetBrewer::met.brewer("Renoir")) +
  labs(fill = "Especies") +
  guides(fill = "none")
```


Por 칰ltimo vamos a probar el paquete `{ggparliament}` (puedes ver su [documentaci칩n]("https://r-charts.com/part-whole/ggparliament/")), para la <mark>**representaci칩n de esca침os**</mark> (los partidos que se presentan a unas elecciones son variables cualitativas, y sus esca침os sus frecuencias absolutas.

Para ilustrarlo vamos a usar el conjunto `election_data` de dicho paquete, que contiene los <mark>**datos electorales de Rusia, Australia, Alemnia, UK y Estados Unidos**</mark>


```{r}
# install.packages("ggparliament")
library(ggparliament)
election_data
```

Vamos a <mark>**filtrar solo los resultados de Rusia del 2016**</mark>

```{r}
rusia <- election_data %>%
  filter(country == "Russia" & year == 2016)
```

Con la funci칩n `parliament_data` construiremos los datos, preparados para ser <mark>**visualizados en formato hemiciclo**</mark> (con `parl_rows` le indicamos las fila del parlamento).

```{r}
rusia_parlamento <-
  as_tibble(parliament_data(election_data = rusia, type = "semicircle",
                            parl_rows = 9, party_seats = rusia$seats))
rusia_parlamento
```

F칤jate que por defecto ha incluido ya un color por partido (que podr칤amos cambiar en `{ggplot2}`. Tras ello, y dentro de la filosof칤a `{ggplot2}`, podremos representar los datos de nuestro parlamento.

```{r}
parlamento <-
  ggplot(rusia_parlamento,
       aes(x = x, y = y, colour = party_short)) +
  geom_parliament_seats()
parlamento
```

Podemos a침adir las etiquetas de los partidos as칤 como el n칰mero total de esca침os

```{r}
parlamento +
  draw_partylabels(type = "semicircle",
                   party_names = party_long,
                   party_seats = seats,
                   party_colours = colour) + 
  draw_totalseats(n = 450, type = "semicircle")
```

Con `theme_ggparliament()` tenemos un tema ya preparado para la representaci칩n del hemiciclo, y a침adimos t칤tulos y colores.

```{r}
parlamento +
  draw_totalseats(n = 450, type = "semicircle") +
  theme_ggparliament() +
  labs(color = "Partidos",
       title = "Resultados de las elecciones de Rusia 2016") +
  scale_colour_manual(values = rusia_parlamento$colour, 
                      limits = rusia_parlamento$party_short) +
  theme(plot.margin = margin(t = 4, r = 4, b = 4, l = 8, "pt"),
        plot.title = element_text(size = 30))
```


## 游닇 Ejercicios

en construcci칩n

